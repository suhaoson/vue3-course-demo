### 如何理解和使用Vue 3的响应式数据？

Vue.js 最开始的响应式实现是基于 ES6 的一个 Object.defineProperty 的特性拦截监听数据变化，一旦监听到数据变化就触发对应依赖数据的模板重新渲染。<br/>
Vue.js 的 3.x 版本，响应式就换成基于 ES6 的 Proxy 特性。Proxy 能监听一个对象的“读数据”和“写数据”的操作。

#### 响应式数据的基本操作

<b>reactive</b>

```
<template></template>

<script setup>
import { reactive } from 'vue';
const state = reactive({
  count: 0
});

// 答应响应式数据内容
console.log(state)
</script>
```
执行这个 Vue.js 3 代码，在浏览器控制台打印的结果如下图所示：
![](https://static001.geekbang.org/resource/image/4d/57/4d245081011bf38cd5bb61612fa08457.png?wh=1824x614)
我们可以看到，reactive 生成的响应式数据是一个 Proxy 数据。<br/>

#### 什么是 Proxy?

Proxy 是 ES6 的一个新语法，功能与其英文字面意思一样，就是提供“代理”的功能，可以让对象数据实现属性的读和写操作的代理拦截处理，具体的使用方法你可以参考[MDN 技术文档对 Proxy 的介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 。
通过上述内容，我们可以知道 Vue.js 3 的响应式 API reactive 是把对象数据转成 Proxy 类型数据进行数据的“代理”和“监听”

<b>ref</b>

ref 就是 Vue.js 3 官方提供的另一个响应式 API，count 就是通过响应式 API 声明的响应式数据。如果我们要修改这个 count 数据，就需要借助 count.value 属性来“间接”修改这个响应数据。<br/>
这里的 ref 可以接收一个基础数据类型或者对象数据类型，最后根据不同数据类型返回不同的响应式数据。

```
<template>
  <div>{{count}}</div>
  <div>{{state.count}}</div>
</template>

<script setup>
import { ref } from 'vue';
const count = ref(1);
const state = ref({
  count: 2
});

// ref 传入基本类型Number后 响应式数据内容
console.log(count)

// ref 传入对象数据后 响应式数据内容
console.log(state)
</script>
```

![](https://static001.geekbang.org/resource/image/46/82/460739c87643dbdb3408c1ddc3992582.png?wh=1818x1318)

<b>为什么 ref 需要返回一个 RefImpl 类型，而不是直接返回 Proxy 类型呢？</b>

这是因为 Proxy 只能代理监听对象类型的数据，例如 JSON 和 Array 数据，但是监听不了单纯的基础类型数据，例如 Number、String 之类。这个时候我们就需要设置一个 value 属性的对象来处理对基础类型数据的代理监听操作，下面举一个简单的例子：
```

const data = {
  _value: 1,
  get value() {
    console.log('我代理监听到 “读” Number数据操作，即将返回1')
    return this._value;
  },
  set value(val) {
    console.log('我代理监听到 “写” Number数据操作，即将设置新数据' + val)
    this._value = val;
  }
}

// 读数据时，会打印出监听的日志 '我代理监听到 “读” Number数据操作，即将返回1'
data.value;
// 写数据时，会打印出监听的日志 '我代理监听到 “写” Number数据操作，即将设置新数据2'
data.value = 2;
```


Vue.js 3 提供了两个重要的响应式 API，reactive 和 ref，他们都可以生成响应式数据，<b>而且 ref 可以接收基础类型和对象类型数据，但是 reactive 只能接收对象类型数据</b>。

#### ref 和 reactive 如何选择使用？
如果是要定义对象类型的响应式数据，那么我们可以优先选择 reactive 来定义，这样子在 JavaScript 里可以直接操作对象响应式数据，就不需要多写一个 value 属性来操作了。而且，我们还可以避免对象本身带有 value 属性容易导致的理解上的属性混淆问题。<br/>
如果要定义基础类型的响应式数据，就用 ref 来定义，通过访问基础类型的响应式数据的 value 属性来进行读写操作。<br/>

除了常用的 reactive 和 ref 之外，Vue.js 3 还有其他功能定义不同的响应式 API，你需要在特定场景下进行选择，相关的响应式 API 信息你可以查看[Vue.js 3 的官方文档](https://cn.vuejs.org/v2/api/)。

#### 如何选择合适使用其它响应式 API？
去除响应式”的响应式 API toRaw: 也就是把响应式的关系解除。<br/>
响应式 API watch: 这是监听响应式数据源变化的 API，也就是监听指定响应式数据变化，触发对应的回调函数。常用于处理数据变化的副作用操作，例如输入框经常需要用到监听数据变化做字数统计的操作、统计一些中文文字个数等<br/>

通过我们前面对这两个响应式 API，以及 reactive 和 ref 这两个设置响应式数据的 API 的讲解，你应该能体会到，响应式 API 基本上可以设置响应式数据、解除响应式状态和监听响应式数据这基本三种类型。<br/>

### Vue.js 3 的响应式开发有什么需要注意的?
- 响应式数据解构或者属性赋值后，可能会丢失响应式联系；<br/>
    第一个注意点就是“响应式数据解构或者属性赋值后，可能会丢失响应式联系”。
    ```
        <template>
        <textarea v-model="text" placeholder="文本信息" />
        <div>文本信息：{{text}}</div>
        </template>

        <script setup>
        import { reactive } from 'vue';
        const state = reactive({
        text: '今天是2022年01月01日',
        });
        const { text } = state;
        </script>
    ```
- 慎用浅层响应式作用 API；<br/>
    例如 shallowReactive 和 shallowReadonly。为什么呢？<br/>
    因为 shallowReactive 这类响应式 API 生成的响应式对象数据，只作用对象数据的下一级属性，至于对象的下下一级属性就作用不到了。如果没什么特殊的需求，我们就尽量少用这类 API，这个 Vue.js 3 官方在 API 文档说明也提到过。
- 慎用副作用 API。<br/>
    为什么呢？我来把刚刚的一个代码例子改一下：
    ```
        <template>
        <form>
            <textarea v-model="state.text" placeholder="信息" />
            <div>中文字数：{{state.zhCount}}</div>
        </form>
        </template>

        <script setup>
        import { reactive, watch } from 'vue';

        // 计算文本中文个数函数
        function countZhText(txt) {
        const zhRegExp = /[\u4e00-\u9fa5]{1,}/g;
        const zhList = txt.match(zhRegExp);
        let count = 0;
        zhList.forEach((item) => {
            count += item.length;
        });
        return count;
        } 
        const defaultText = '今天是2022年01月01日'
        const state = reactive({
        text: defaultText,
        zhCount: countZhText(defaultText),
        });

        watch(
        // 监听 state.text 的变化
        [() => state.text, () => state.zhCount ],
        ([ text ], [ prevText ]) => {
            // 每当 state.text 变化，这个打印会触发两次
            console.log('正在监听变化...')
            // 当监听到state.text 变化，就会触发这个回调函数
            state.zhCount = countZhText(text);
        }
        )
        </script>
    ```

> 此文章为3月Day6学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点💪💪
