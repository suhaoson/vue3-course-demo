### 数据库方案设计：如何设计运营搭建平台的数据库？

#### 什么是数据库设计范式？

数据库设计范式，简称“数据库范式”，也经常简称“范式”，英文为 Normal Form，简称 NF，大部分情况是面向“关系型数据库”的设计规范。
<br/>

在计算机相关的教科书里，数据库设计范式是这么定义的。<br/>

> “在关系型数据库里，符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”
> <br/>
> 简单理解就是，如何用合理的方式来设计项目的数据库，让数据库里各种“表”的“关系”更加清晰和简约，减少数据冗余，便于管理。
> <br/>
> 根据严格等级划分，通常分成六种范式（或者理解六种范式级别），从上到下分别为：<br/>

- 第一范式，简称 1NF
- 第二范式，简称 2NF
- 第三范式，简称 3NF
- 巴斯 - 科德范式，Boyce-Codd Normal Form，简称 BCNF
- 第四范式，简称 4NF 第五范式，简称 5NF
- 如果数据库设计范式再深入细分或提升严格等级，就不止这六种范式，还可以分成域键范式（Domain-Key Normal Form，简称 DKNF）、第六范式（简称 6NF）等等。

<br/>
<b>第一范式，是指在关系型数据库的表中，每一个字段都是原子性的，也就是最小原子，不能再拆分。</b>举个例子：
![](https://static001.geekbang.org/resource/image/d0/4d/d028fc1c537a2a1c9aaffc5e283e644d.jpg?wh=5000x2039)
如下表就不满足第一范式：
![](https://static001.geekbang.org/resource/image/88/f8/88526302f141b720e2yyb0b558a7e3f8.jpg?wh=5000x2057)

<br/>
<b>第二范式，在第一范式的基础上新增了一个规则，“不存在非关键字段对任意一候选字段的部分函数依赖”。</b>
<br/>
减少非必要字段的依赖，避免数据的冗余。所以，第二范式可以理解是“数据的唯一性和一致性”
<br/>
<b>第三范式，在第二范式的基础上再新增了一个规则，“任何非主属性不依赖于其他非主属性”。</b>就是要消除传递依赖。

#### 如何做运营搭建平台项目数据库设计？

首先，我们要做数据种类的划分，根据第三范式的严格程度，我们需要尽可能让数据“原子化”、“唯一性”和“消除传递依赖”。运营搭建平台的数据，我们可以分成五类。
<br/>

- 员工用户数据，企业内部操作搭建页面的员工用户
- 物料数据，用于搭建页面的业务组件配置数据
- 物料操作快照，业务组件的日常更新迭代的备份数据、操作日志和版本信息
- 搭建的页面，搭建页面的布局和配置数据
- 页面操作快照，页面日常更新迭代的备份数据、操作日志和版本信息

<br/>
这五个数据种类落在数据库里，也就是五张数据“表”，可以这么定义。

- 员工用户表 user_info
- 物料信息表 material_info
- 物料快照表 material_snapshot
- 页面信息表 page_info
- 页面快照表 page_snapshot

#### SQL 建表语句

基于上面的字段描述，在 MySQL 数据库环境里，我们实现员工用户表的建表 SQL 代码。
<br/>

```
CREATE TABLE  IF NOT EXISTS `user_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uuid` varchar(128) NOT NULL UNIQUE COMMENT '员工用户UUID',
  `username` varchar(64) NOT NULL UNIQUE COMMENT '员工用户名称',
  `password` varchar(64) NOT NULL COMMENT '员工用户密码',
  `status` int(2) NOT NULL COMMENT '状态，0为删除，1为正常状态',
  `info` json COMMENT '描述（JSON数据格式）',
  `extend` json COMMENT '扩展数据（JSON数据格式）',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modify_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

这段 SQL 代码，可以直接在 MySQL 命令环境中执行进行建表。其中“create_time”和“modify_time”的数据操作，利用了数据库的默认能力，当我们插入新数据或修改旧数据时，MySQL 数据库会自动输入创建时间“create_time”或更新最后修改时间“modify_time”。
<br/>
id, uuid, create_time 和 modify_time 等这几个字段基本可以复用，稍作调整修改就可以了。<br/>
看剩余 4 张表的建表 SQL 代码的设计实现。<br/>
物料信息表 material_info。

```
CREATE TABLE  IF NOT EXISTS `material_info` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `uuid` varchar(128) NOT NULL UNIQUE COMMENT '物料UUID',
  `name` varchar(128) NOT NULL UNIQUE COMMENT '物料名称（字母和数字）',
  `current_version` varchar(64) NOT NULL COMMENT '当前版本',
  `info` json COMMENT '描述（JSON数据格式）',
  `extend` json COMMENT '扩展数据（JSON数据格式）',
  `status` int(2) NOT NULL COMMENT '状态，0为删除，1为正常状态',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modify_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

<br/>
物料快照表 material_snapshot。
```
CREATE TABLE IF NOT EXISTS `material_snapshot` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`version` varchar(64) NOT NULL COMMENT '快照版本',
`user_uuid` varchar(128) NOT NULL COMMENT '操作者的用户 UUID',
`material_uuid` varchar(128) NOT NULL COMMENT '物料 UUID',
`material_data` json COMMENT '物料快照数据（JSON 数据格式）',
`extend` json COMMENT '扩展数据（JSON 数据格式）',
`status` int(2) NOT NULL COMMENT '状态，0 为删除，1 为正常状态',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

<br/>
页面信息表 page_info。
```
CREATE TABLE IF NOT EXISTS `page_info` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`uuid` varchar(128) NOT NULL UNIQUE COMMENT '页面 UUID',
`name` varchar(128) NOT NULL UNIQUE COMMENT '页面名称（字母和数字）',
`current_version` varchar(64) NOT NULL COMMENT '当前版本',
`layout` json COMMENT '布局互数据（JSON 数据格式）',
`info` json COMMENT '描述（JSON 数据格式）',
`extend` json COMMENT '扩展数据（JSON 数据格式）',
`status` int(2) NOT NULL COMMENT '状态，0 为删除，1 为正常状态',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`modify_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

<br/>
页面快照表 page_snapshot。
```
CREATE TABLE IF NOT EXISTS `page_snapshot` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`version` varchar(64) NOT NULL COMMENT '快照版本',
`user_uuid` varchar(128) NOT NULL COMMENT '操作者的用户 UUID',
`page_uuid` varchar(128) NOT NULL COMMENT '页面 UUID',
`page_data` json COMMENT '页面快照数据（JSON 数据格式）',
`extend` json COMMENT '扩展数据（JSON 数据格式）',
`status` int(2) NOT NULL COMMENT '状态，0 为删除，1 为正常状态',
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### 如何实现项目的数据库初始化操作？

基于 SQL 批量建表这个没有标准答案，不同企业里不同程序员都是“八仙过海各显神通”，有的用 MySQL 的可视化建表工具，有的用企业内部的数据库工具，也有的直接用 MySQL 的命令工具。<br/>

那么有没有优雅的办法，实现项目的数据库建表初始化呢？<br/>
<b>最低成本的方式，就是用脚本实现自动化建表，初始化数据库。</b>
<br/>
既然我们用 Node.js 来做 Web 服务，也可以用 Node.js 这个脚本环境来实现自动化建库。主要分成三个步骤。
<br/>

1. 第一步，准备 Node.js 环境里的建库方法和建表方法，我们沿用上节课的数据库操作方法。

```

import mysql from 'mysql';
import dotenv from 'dotenv';

dotenv.config();

export const database = process.env.MYSQL_DATABASE;

const config = {
host: process.env.MYSQL_HOST,
port: parseInt(process.env.MYSQL_PORT),
user: process.env.MYSQL_USER,
password: process.env.MYSQL_PASSWORD
};

const pool = mysql.createPool(config);
const poolDatabase = mysql.createPool({ ...config, ...{ database } });

export function querySQLByPool(sql: string) {
return new Promise((resolve, reject) => {
pool.query(sql, (err, results, fields) => {
if (err) {
pool.end();
reject(err);
} else {
pool.end();
resolve({ results, fields });
}
});
});
}

export function queryDatabaseSQLByPool(sql: string) {
return new Promise((resolve, reject) => {
poolDatabase.query(sql, (err, results, fields) => {
if (err) {
pool.end();
reject(err);
} else {
pool.end();
resolve({ results, fields });
}
});
});
}

export function queryDatabaseSQL(sql: string, values: (string | number)[]) {
const conn = mysql.createConnection({ ...config, ...{ database } });
conn.connect();
return new Promise((resolve, reject) => {
conn.query(sql, values, (err, rows) => {
if (err) {
conn.end();
reject(err);
} else {
conn.end();
resolve(rows);
}
});
});
}

export function closePools() {
pool.end();
poolDatabase.end();
}
```

2. 第二步，准备所有初始数据库的 SQL 代码，参考前面写好的所有建表的 SQL 代码。
3. 第三步，编写建表逻辑脚本。

```
/_ eslint-disable no-console _/
import {
database,
querySQLByPool,
queryDatabaseSQLByPool,
queryDatabaseSQL,
closePools
} from './util';
import sqlUserInfo from './sql/user_info.sql?raw';
import sqlPageInfo from './sql/page_info.sql?raw';
import sqlPageSnapshot from './sql/page_snapshot.sql?raw';
import sqlMaterialInfo from './sql/material_info.sql?raw';
import sqlMaterialSnapshot from './sql/material_snapshot.sql?raw';

async function initDatabase() {
const sqlDB = `CREATE DATABASE IF NOT EXISTS ${database};`;
await querySQLByPool(sqlDB);
console.log(`运营搭建平台 - 数据库 ${database} 建库成功！`);

await queryDatabaseSQLByPool(sqlUserInfo);
console.log(`运营搭建平台 - 数据库 ${database} 建表 user_info 成功！`);

await queryDatabaseSQLByPool(sqlPageInfo);
console.log(`运营搭建平台 - 数据库 ${database} 建表 page_info 成功！`);

await queryDatabaseSQLByPool(sqlPageSnapshot);
console.log(`运营搭建平台 - 数据库 ${database} 建表 page_snapshot 成功！`);

await queryDatabaseSQLByPool(sqlMaterialInfo);
console.log(`运营搭建平台 - 数据库 ${database} 建表 material_info 成功！`);

await queryDatabaseSQLByPool(sqlMaterialSnapshot);
console.log(
`运营搭建平台 - 数据库 ${database} 建表 material_snapshot 成功！`
);

console.log(
`运营搭建平台 - 数据库 ${database} 建表 material_snapshot 成功！`
);

await closePools();

const userInfoCount: { user_count: number }[] = (await queryDatabaseSQL(
'SELECT COUNT(\*) AS user_count FROM user_info;',
[]
)) as { user_count: number }[];
if (userInfoCount?.[0]?.user_count === 0) {
console.log(`运营搭建平台 - 数据库 ${database}.user_info 表暂无数据`);
await queryDatabaseSQL(sqlInsertUserInfo, []);
console.log(
`运营搭建平台 - 数据库 ${database} 插入初始数据到 user_info 表成功！`
);
console.log('运营搭建平台 - 完成数据库初始化！');
}
}

async function init() {
await initDatabase();
}

init();
```

**我是用 vite-node 这个工具来启动我们的 TypeScript 脚本，在 Node.js 环境里，自动地初始化数据库。其中，“import”加载 SQL 代码文件的“?raw”标记是 Vite 环境的支持操作，不要误会成 TypeScript 或者 Node.js 的规范。**
这个自动化建库建表的初始化操作，也可以对企业项目不同环境的数据进行初始化，比如本地开发环境、项目测试环境、预发布环境和生产环境。主要是修改配置。

> 此文章为 3 月 Day21 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
