#### 服务端功能扩展：如何对 Vue.js 全栈项目做服务端功能扩展？

搭建平台要扩展更多功能的时候，单纯扩展页面是远远不够的，我们还需要整个服务端链路提供扩展的规范和能力。

#### 为什么需要学习服务端功能扩展的内容

站在职场视角上，没有绝对的技术立场和标准答案，你要根据实际工作场景的需要作选择。我个人认为有三个关键因素。<br/>

1. Vue.js 必须依赖 Node.js。<br/>
   第一点是必要因素。Vue.js 的运营搭建平台页面，离不开 Node.js 服务。<br/>
   最核心的原因就是 Vue.js 的技术生态都是基于 Node.js 建设的。
2. 搭建场景侧重前端主导。<br/>
   第二点，搭建场景，也就是搭建平台场景，大量业务和开发的重心，都是前端相关的内容，侧重前端主导。<br/>
   搭建操作需要的数据模型、HTTP 接口和功能操作逻辑，应该更加侧重于满足“前端搭建”的诉求。
3. Node.js 开发岗位的局限性。<br/>
   第三点，Node.js 开发岗位的局限性<br/>
   因为 Node.js 的开发语言，和传统前端领域使用的 JavaScript 语言一致，而在大部分企业里，主流的服务端开发语言都是 Java、Python 等传统后端语言，所以，Node.js 服务端开发工作，大部分都是由前端程序员主导的。

<br/>
前端程序员要学习服务端功能扩展的知识点，总的来说业务场景需要和技术场景局限”。

#### 如何设计搭建平台服务端的扩展规范

首先整理运营搭建平台在业务扩展、技术扩展两方面所需要的能力。

##### 业务扩展能力

- 业务数据扩展<br/>
  第一点业务数据扩展，扩展范围主要分为“新增数据类型”和“调整数据内容”。<br/>
  “新增数据类型”，你可以理解就是扩展出新的数据内容。<br/>
  “调整数据内容”，就是要对原有数据内容或者结构做扩展。<br/>
- 功能操作扩展逻<br/>
  第二点功能操作扩展，对原有的操作逻辑进行调整或者新增操作。
- 辑状态扩展<br/>
  最后一点，逻辑状态扩展，就是扩展相关内容的状态逻辑。

<br/>

##### 技术扩展能力

- 路由层扩展
- 控制层扩展
- 业务层扩展
- 数据层扩展

服务端的技术扩展，我们用技术的结构图来分析。<br/>
![](https://static001.geekbang.org/resource/image/a0/23/a0bc0d2cb831d2d6d652b278336a1523.jpg?wh=4000x2636)

<b>对于业务功能来说，每个分层，都是以独立的原子模块存在的。</b>一个层级的某个功能，是由下一个层级中的一个或多个原子模块组合而成，或者同层级的一个或多个功能模块组合而成。

##### 如何扩展

如果是业务扩展，一般是基于业务的纵向扩展；如果单纯是技术能力的扩展，为了保持各个分层独立，一般都是横向每个分层独立扩展。所以，现在我们有两个扩展方向，<b>基于业务的纵向扩展、基于技术的横向扩展。</b>

<br/>
我们这里讲到的横向和纵向切面结构，其实跟项目代码案例的文件目录结构是一一对应的。
![](https://static001.geekbang.org/resource/image/8f/07/8f4f4c74dc8a6e8ef4813fa690892107.png?wh=1920x1288)

##### 如何实现纵向切面的功能扩展

服务端纵向切面的功能扩展，就是贯穿服务端分层，实现每层的功能模块，我们要梳理原有分层中的模块内容，以及新增模块如何存放。
<br/>

先梳理模块内容：
![](https://static001.geekbang.org/resource/image/ae/90/ae688b037d1fedf76d80a671e94ff690.jpg?wh=4000x2636)

扩展的功能，按照需要，我们要选择合适的纵向位置，新增子模块。<br/>

例如，在要实现一个用户登录记录功能，我们需要从纵向切面，在需要的分层实现对应的模块。

![](https://static001.geekbang.org/resource/image/ed/0a/ed11696ee59d72b0d0094f8daa2dab0a.jpg?wh=4000x2636)
参考示意图，我们分成三部分：
![](数据层，新增“用户登录行为数据表”和数据库操作，实现“插入登录数据”的操作模块。)
![](业务层，使用数据层的数据库操作方法，实现登录用户的“记录登录行为”的操作模块。)
![](控制层，判断用户是否在登录状态下，再使用业务新增的记录模块，主要实现“逻辑操作扩展”。)

#### 如何实现横向切面的功能扩展

服务端横向向切面的功能扩展就是在同一个分层中，新增需要功能的子模块，一般侧重于技术层面的需要。<br/>

比如，要新增一个路径前缀，读取其它目录的静态资源内容。那么扩展功能就要在“路由层”中开展工作。

![](https://static001.geekbang.org/resource/image/b0/e1/b063b26be9b1fd5d978d5c5e51460be1.jpg?wh=4000x2636)

<br/>
看示意图，原有的静态资源在路由层中，判断前缀是“/public”，就读取原有静态目录“/public”，现在，我们新增了一个新静态资源路径前缀“/static”，读取新的一个静态资源目录。
<br/>

基于 Koa.js 代码来扩展，示例代码如下：

```
// packages/work-server/src/index.ts
import path from 'node:path';
import Koa from 'koa';
import koaStatic from 'koa-static';
import koaMount from 'koa-mount';
// ...

const app = new Koa();
// ...

const publicDirPath = path.join(getServerDir(), 'public');
app.use(koaMount('/public', koaStatic(publicDirPath)));

// 静态资源路径前缀“/static”，读取新的一个静态资源目录
const staticDirPath = path.join(getServerDir(), 'static');
app.use(koaMount('/static', koaStatic(staticDirPath)));

// ...
```

#### 服务端扩展还有哪些更优雅的方式

答案是有的，我们要利用所使用 Web 服务框架特性。比如课程里选择的 Koa.js 服务框架，具有洋葱模型的中间件体系，天然就是一种服务端优雅的扩展方式。
<br/>

复习一下 koa.js 洋葱模型的代码：

```
const context = {};

async function middleware1(ctx: any, next: any) {
  console.log('打印 001');
  await next();
  console.log('打印 004');
}

async function middleware2(ctx: any, next: any) {
  console.log('处理HTTP响应之前');
  await next();
  console.log('处理HTTP响应之前');
}

async function middleware3(ctx: any, next: any) {
  console.log('打印 002');
  await next();
  console.log('打印 003');
}

Promise.resolve(
  middleware1(context, async () => {
    return Promise.resolve(
      middleware2(context, async () => {
        return Promise.resolve(
          middleware3(context, async () => {
            return Promise.resolve();
          })
        );
      })
    );
  })
).then(() => {
  console.log('执行结束');
});
```

代码可以用这张中间件模型的示意图来描述。
![](https://static001.geekbang.org/resource/image/9d/bd/9d70yyf2ca465862aea95ef1af818ebd.jpg?wh=1920x1197)
可以看出，在一个 HTTP 请求过程中，可以对每个中间件执行两次操作，而且，越往头部的中间件，两次执行操作，越靠近 HTTP 请求和响应的两端。我们可以利用这个机制，<b>以 HTTP 切面为线索，开发中间件来扩展功能。</b><br/>

比如扩展 HTTP 请求日志记录功能，看具体扩展设计图。
![](https://static001.geekbang.org/resource/image/02/c0/02b3bf1c6bdeb132c7d95a6862d0f5c0.jpg?wh=4000x2636)

于这张的 HTTP 请求记录的设计图，可以这么来实现代码。<br/>

```
import type { Context, Next } from 'koa';

export async function record(ctx: Context, next: Next) {
  const info = `[${ctx.method}] ${ctx.url}`;
  // 进入内部中间件前的时间戳
  const start = Date.now();
  // 进入内部中间件前
  await next();
  // 跳出内部中间件后
  console.log(`${info} 执行内部所有中间件耗时 ${Date.now() - start}ms`);
  // 监听相应结束
  ctx.res.on('finish', () => {
    console.log(`${info} 请求完整耗时 ${Date.now() - start}ms`);
  });
}
```

在项目最开始使用中间件前，使用这个日志记录中间件。

```
// packages/work-server/src/index.ts
import path from 'node:path';
import Koa from 'koa';
import koaStatic from 'koa-static';
import koaMount from 'koa-mount';
import koaBodyParser from 'koa-bodyparser';
import routers from './router';
import { getServerDir } from './util/file';
import { syncFileFromCDN } from './middleware/sync-cdn';
import { record } from './middleware/record';

const app = new Koa();

// 使用扩展的 HTTP 日志打印中间件
app.use(record);

const publicDirPath = path.join(getServerDir(), 'public');
app.use(koaBodyParser());
app.use(koaMount('/public', koaStatic(publicDirPath)));
app.use(syncFileFromCDN);
app.use(routers);

const port = 8001;
app.listen(port, () => {
  console.log('服务启动: http://127.0.0.1:' + port);
});
```

使用中间件后，控制台可以看到所有 HTTP 请求的耗时日志打印情况。
<br/>
![](https://static001.geekbang.org/resource/image/c3/b6/c3a2abcd3691232b6789b3f1442e0bb6.png?wh=1920x1264)

<br/>

> 此文章为 4 月 Day4 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
