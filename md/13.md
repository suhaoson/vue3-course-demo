### 动态表单组件：怎么优雅地动态渲染表单？

假设你接到一个业务需求，要开发一个“用户信息设置”的页面，按照常规开发步骤，我们一般是用表单组件来封装这个用户信息配置的功能。<br/>
但接下来业务需求变了，业务方要做用户类型的区分，不同类型的用户显示“不同个人信息配置”，比如这里就有“普通用户”、“多种等级会员用户”的信息配置，后续可能会新增其他维度类型的用户信息配置。
<br/>
那么，是否有一种表单方案，能够通过简单的自定义配置，快速生成对应的表单功能呢？<br/>
答案是有的，就是“动态表单组件”。
<br/>

#### 什么是动态表单？

<b>动态表单，核心就是通过自定义数据来动态生成自定义表单。</b>

#### 如何用 Vue.js3.x 实现最简单的动态表单？

实现一个最简单的表单组件，其实就是根据自定义数据，来自定义生成表单数据组件的各种组合。
<br/>

实现步骤现在就很清晰了：
<br/>

1. 第一步，列举要用到的表单数据组件，例如 input，radio 等；
2. 第二步，定义描述动态表单的数据格式；
3. 第三步，根据数据格式来渲染动态表单。

<br>
看代码：

```
<template>
  <form class="dynamic-form" @submit="onSubmit">
    <div class="dynamic-form-title">{{ schema.title }}</div>
    <div
      class="dynamic-form-field"
      v-for="(field, index) in schema.fieldList"
      v-bind:key="index"
    >
      <div class="dynamic-form-label">{{ field.label }}：</div>
      <div v-if="field.fieldType === 'input'" class="dynamic-form-item">
        <input v-model="model[field.name]" />
      </div>
      <div v-else-if="field.fieldType === 'radio'" class="dynamic-form-item">
        <span
          v-for="(option, index) in field.options"
          v-bind:key="index"
          class="dynamic-form-option"
        >
          <input
            type="radio"
            :id="option.value"
            :name="field.name"
            :value="option.value"
            :checked="model[field.name] === option.value"
            @change="
              onRadioChange({ fieldName: field.name, value: option.value })
            "
          />
          <label :for="option.value">{{ option.name }}</label>
        </span>
      </div>
      <div v-else class="dynamic-form-item"></div>
    </div>
    <div>
      <button class="dynamic-form-btn" type="submit">提交</button>
    </div>
  </form>
</template>

<script setup lang="ts">
import { reactive, toRaw } from 'vue';

const schema = {
  title: '普通用户信息',
  filedList: [
    {
      label: '用户名称',
      name: 'usename',
      fieldType: 'input'
    },
    {
      label: '手机号码',
      name: 'phone',
      fieldType: 'input'
    },
    {
      label: '收货地址',
      name: 'address',
      fieldType: 'input'
    }
  ]
};

const model = reactive<{ [key: string]: unknown }>({});
schema.fieldList.forEach((field) => {
  model[field.name] = '';
});

const onRadioChange = (data: { fieldName: string; value: string }) => {
  model[data.fieldName] = data.value;
};

const onSubmit = (e: Event) => {
  e.preventDefault();
  window.alert(JSON.stringify(data));
};
</script>
<style> /* 样式代码省略，请看代码案例 */ </style>
```

<br/>
schema 定义的动态表单数据，是一个“普通用户”的数据，表单的动态渲染结果如下图所示：
![](https://static001.geekbang.org/resource/image/79/3e/79a7b31f77d1d02747fd28a43156203e.png?wh=1366x822)
这个简单的动态表单，内部支持了两种表单数据组件，input 输入框和 radio 单项选择，现在我们把 schema 修改一下，改成“会员用户信息”的数据，代码如下：

```
const schema = {
  title: '会员用户信息',
  fieldList: [
    {
      label: '用户名称',
      name: 'usename',
      fieldType: 'input'
    },
    {
      label: '手机号码',
      name: 'phone',
      fieldType: 'input'
    },
    {
      label: '优惠服务',
      name: 'service',
      fieldType: 'radio',
      options: [
        { name: '免运费', value: 'service001' },
        { name: '9折优惠', value: 'service002' },
        { name: '满80减10', value: 'service003' }
      ]
    },
    {
      label: '收货地址',
      name: 'address',
      fieldType: 'input'
    }
  ]
}
```

这里的“会员用户”表单描述数据，比“普通用户”的多了一个“优惠服务”的表单描述字段，动态表单渲染效果如下：
![](https://static001.geekbang.org/resource/image/3c/72/3c36761e8f8c4526ebe1b568f236d172.png?wh=1456x864)

通过，这样一个简单的 Vue.js 3.x 动态表单实现，我们可以总结出动态表单实现的三个核心要素：

- 第一点，梳理要用到的表单数据组件；
- 第二点，根据表单数据组件种类制定数据格式；
- 第三点，根据数据格式的内容，来渲染表单数据组件的自定义组合，这个自定义组合就是所需要的表单结果。

#### 如何设计和实现完善的动态表单组件？

在具体实现之前，我们先设计动态表单组件的规范。这个规范除了能满足现有的功能需要，还需要有前瞻性的设计，保证能扩展“新的表单动态组件”，不能局限于一开始约定的表单数据组件。<br/>
按照要求，再结合实现最简单的动态表单的核心要素，我重新梳理了四点实现要素：

- 定义表单数据组件的统一 API；
  我们需要约定好统一的表单数据组件的 API，对不同表单数据组件做 API 统一封装。
- 定义默认支持的数据表单组件；
  常用的表单数据组件要在动态表单内默认支持，所以我们要用统一的 API 进行二次封装，并内置到动态表单组件内。这里表单数据组件的 API 统一代码如下所示：

  ```
  const props = defineProps<{
  // 传入的数据值
  value: string | any;
  // 组件内部选项参数，例如多选框，单选框，下拉框的选项数据
  options: Array<{ name: string; value: string }>;
  }>();

  const emits = defineEmits<{
  // 监听组件内部数据变化事件
  (e: 'change', value: string): void;
  }>();
  ```

- 支持自定义表单字段的校验规则；
  自定义表单校验规则，对动态表单来讲也很重要，我们可以把上节课的表单字段组件，沿用到我们的动态表单组件里，统一管理表单校验。
- 支持根据统一 API 扩展自定义表单数据组件。
  既然要实现动态表单组件，我们就不能只支持默认表单数据组件的表单生成。所以，我们这里需要支持可扩展自定义表单数据组件，但有个前提，就是自定义表单数据组件要按照第一点要素的内容，封装统一的 API。
  实现动态表单组件，看代码:

  ```
    <template>
    <div :class="{ [baseClassName]: true }">
        <Form>
        <Form
            ref="formRef"
            :model="internalModel"
            @finish="onFinish"
            @finishFail="onFinishFail"
        >
            <FormItem
            v-for="(field, index) in fieldList"
            :key="index"
            :label="field.label"
            :name="field.name"
            :rule="field.rule"
            >
            <component
                :is="registerComponentMap[field.fieldType]"
                :value="internalModel[field.name]"
                :options="field.options || []"
                @change="(value: unknown) => { onFieldChange({ name: field.name, value }) }"
            />
            </FormItem>
            <Row v-if="$slots.default">
            <slot></slot>
            </Row>
        </Form>
        </Form>
    </div>
    </template>

    <script setup lang="ts">
    import { reactive } from 'vue';
    import { prefixName } from '../theme';
    import Row from '../row';
    import Form from '../form';
    import Input from '../input';
    import RadioList from '../radio-list';
    import type { Component } from 'vue';
    import type { DynamicFormField } from './common';

    // 内置支持的表单数据组件
    const registerComponentMap: { [key: string]: Component } = {
    Input: Input,
    RadioList: RadioList
    };

    const props = withDefaults(
    defineProps<{
        fieldList?: DynamicFormField[];
        model?: { [name: string]: unknown };
    }>(),
    {}
    );

    const internalModel = reactive<{ [name: string]: unknown }>(props?.model || {});
    const FormItem = Form.FormItem;
    const baseClassName = `${prefixName}-dynamic-form`;

    const onFieldChange = (event: { name: string; value: string | unknown }) => {
    internalModel[event.name] = event.value;
    };

    const emits = defineEmits<{
    (event: 'finish', e: unknown): void;
    (event: 'finishFail', e: unknown): void;
    }>();

    const onFinish = (e: unknown) => {
    emits('finish', e);
    };

    const onFinishFail = (e: unknown) => {
    emits('finishFail', e);
    };

    </script>

  ```

code...

> 此文章为 3 月 Day14 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
