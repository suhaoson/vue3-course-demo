### 用户注册和登录：如何结合 Vue 3 和 Koa.js 实现注册登录？

#### 如何设计注册和登录的功能逻辑？

注册示意图：
![](https://static001.geekbang.org/resource/image/53/1e/53b85a43222daf4e5f8a4c77ae62951e.jpg?wh=1920x1080)

- 第一步，用户输入和提交“待注册”账号密码。这一步中，功能上要辅助用户校验用户名称是否符合规范，同时，要辅助用户校验两次密码是否一致。
- 第二步，用户提交注册信息，处理注册逻辑。这时候要平台判断账号是否存在，判断是否能注册，并处理注册结果。如果用户名称已存在，就准备好失败提示结果，如果用户名称不存在，就注册用户信息。
- 第三步，处理注册后的结果。如果用户注册成功，就自动跳转到登录页面，如果用户注册失败，显示失败原因，提醒用户如何改正。

登录示意图：
![](https://static001.geekbang.org/resource/image/01/4b/0128eb0328f3f986084790b769bed54b.jpg?wh=1920x1080)

- 第一步，用户输入和提交“已注册”账号密码。
- 第二步，用户提交登录信息。这时候平台需要判断账号密码是否正确，并返回登录成功或者失败的结果。
- 第三步，处理登录后的结果。如果登录成功，自动跳转管理页面，如果登录失败，显示失败原因。

#### 如何设计用户注册和登录的技术方案？

根据设计方案功能转为技术代码。
<br/>

##### 注册流程的技术方案

注册方案设计图：
![](https://static001.geekbang.org/resource/image/2b/65/2b20a8ac264ed274b02a70281dbfb965.jpg?wh=1920x1080)

- 第一步，前端提交“待注册”的账号和密码。<br/>
  根据动态表单实现注册表单功能，并基于动态表单来做新校验。提交前将密码进行 md5 加密。
- 第二步，服务端接收到 HTTP 请求，解析出表单里的账号和密码。<br/>
  我们是用 Koa.js 来搭建的 Web 服务，那么要解析出 HTTP 的表单数据，也就是注册用户的信息，可以用 Koa.js 的中间件“koa-bodyparser”来解析。
- 第三步，服务端处理注册的数据逻辑。<br/>
  校验用户名是否存在，能否进行注册流程。如果失败返回失败结果。如果可以注册，继续注册的数据操作，这里进行第二次 md5 加密。
- 第四步，浏览器接处理服务端 HTTP 响应结果。<br/>

##### 登录流程的技术方案

注册方案设计图：
![](https://static001.geekbang.org/resource/image/ae/f2/aeb1acbd8c532afd521a8232b1e77ef2.jpg?wh=1920x1080)

- 第一步，前端提交“已注册”的账号和密码，这时候前端也可以用动态表单，来实现登录的页面交互功能。<br/>
  前端要密码用 md5 做第一次加密，最后以表单形式发起 POST 异步 HTTP 请求给服务端。
- 第二步，服务端接收 HTTP 请求，解析出表单里的账号和密码，具体技术实现跟注册技术方案的第二步一样。
- 第三步，服务端校验账号和密码是否正确。<br/>
  如果账号和密码正确，就在 Control 层设置 HTTP 的 Cookie 作为登录态，再返回成功结果。如果账号和密码匹配不上，就返回失败结果。
- 第四步，浏览器处理 HTTP 响应结果。如果注册成功，就设置定时器自动跳转管理页面，如果注册失败，就提示失败原因。

#### 什么是“用户登录态”？

当用户登录成功后，标记在浏览器端、客户端或者服务端的数据，作为登录判断的唯一标识，就是“用户登录态”，一般简称为“登录态”。
<br/>
<b>在 Web 服务中，登录态通常用来在每个 HTTP 请求中，判断是否存在登录数据。</b>
<br/>

在 Web 领域里，登录态的信息有两种标记方法。<br/>

1. 基于 HTTP 的 Cookie 能力，标记在浏览器端。
2. 标记在服务端，术语是 Session，实现技术一般都是服务端的存储技术，例如缓存或数据库。

<br/>

#### 如何使用 JWT 来管理用户登录态？

JSON Web Token 技术，简称“JWT”。 更低成本的把 Cookie 的数据在浏览器里加密，然后在服务器里解密。
<br/>

具体实现步骤:

- 第一步，生成 JWT。当用户登录成功后，服务器把用户数据封装成 JSON 对象，然后进行加密，成一个“加密字符串”，响应返回给浏览器。
- 第二步，存储 JWT。这时候，浏览器可以把这个“加密字符串”存在 localStorage 里，或者服务器响应时存在 Cookie 里。
- 第三步，浏览器使用 JWT 和服务器校验 JWT。这时候，浏览器发送 HTTP 请求的过程中，可以把“加密字符串”加到 HTTP Header 里，或者放在 HTTP Body 里，或者自动跟随在 Cookie 里。当服务端接收到 HTTP 请求后，从 HTTP 的 Header、Body 或者 Cookie 里拿到 JWT，进行解密，把 JSON 数据拿出来检查是否符合要求。

#### 如何根据技术方案进行代码实现？

首先是前端部分，前端的实现用之前课程里的动态表单进行封装，来实现注册的表单。
<br/>

```
template
code...
```

服务端的注册功能，我们根据之前的服务端分层 Router、Controller、Service、Model 逐一实现。<br/>

首先是 Router，也就是路由层，要注册 HTTP 的注册 API。

```
// packages/work-server/src/router.ts
import Router from '@koa/router';
import {
  signUp,
} from './controller/user';
// 其它省略代码 ...

router.post('/api/post/account/sign-up', signUp);
// 其它省略代码 ...
const routers = router.routes();

export default routers;
```

注册了路由，接下来就是实现路由层 Router 上的控制层 Controller 的用户注册方法。<br/>

```

// packages/work-server/src/controller/user.ts
import type { Context, Next } from 'koa';
import { registerUser, queryAccount } from '../service/user';

// 其它省略代码 ...
export async function signUp(ctx: Context) {
  const params = ctx.request.body as {
    username?: string;
    password?: string;
  };
  const result = await registerUser(params);
  ctx.body = result;
}
// 其它省略代码 ...
```

实现了控制层 Controller 的注册方法，接下来就实现其所依赖的业务层，Service 的注册逻辑方法。

```

// packages/work-server/src/service/user.ts
import {
  checkUserIsUsernameExist,
  createUser
} from '../model/user';
import type { MyAPIResult } from './types';
import type { UserInfo } from '../model/user';

export async function registerUser(params: {
  username?: string;
  password?: string;
}): Promise<MyAPIResult> {
  const { username, password } = params;
  let result: MyAPIResult = {
    data: null,
    success: false,
    message: '注册失败'
  };
  if (!username || !password) {
    result.message = '信息不全';
    return result;
  }

  try {
    const isExist = await checkUserIsUsernameExist({ username });
    if (isExist === true) {
      result.message = '用户名已存在';
      return result;
    }
    const createResult = await createUser({ username, password });
    result = {
      data: createResult,
      success: true,
      message: '注册成功'
    };
  } catch (err: any) {
    // eslint-disable-next-line no-console
    console.log(err);
    result.message = err?.toString() || '出现异常';
  }
  return result;
}
```

在业务层 Service 的注册方法 registerUser 中，实现逻辑是先查询是否存在用户名，如果不存在就可以进行注册操作。所以，这里依赖了数据模型层 Model 中的两个方法。
<br/>

那接下来，我们就实现数据库操作的数据库模型层。

```
code...
```

[TODO 完整代码在这里...](../main/)<br/>

> 此文章为 3 月 Day22 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
