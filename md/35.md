### 多进程部署：如何最大限度利用服务器资源运行Node.js服务？

在前端页面性能优化中，我提到两种优化思路，“前置优化”和“后置优化”。<br/>
服务端开发方面的优化工作，主要在性能上。

#### 为什么 Node.js 会发生阻塞

服务端的性能问题，说到底其实就是机器资源的使用问题，主要是 CPU 和内存的利用问题。<br/>
主要的极端原因有两个：
<br/>
- 机器资源不够用
- 机器资源利用不充分

Node.js 是运行 JavaScript 语言的一种环境，而 JavaScript 是“单线程语言”，按照 JavaScript 语法执行逻辑，在 Node.js 环境里的执行过程也是单线程的。<br/>

<b>总的来说，在 Node.js 环境里，默认单线程执行程序。</b><br/>

举个例子，你可以类比成“发快递”。单线程就是一个快递员派件，他知道所有地址，交通工具只有自己用，按部就班进行派件。多线程就是多个快递员派件，虽然多人并行派件，但是要分配工作事项、共用交通工具，增加了很多“管理成本”，类似多线程的“繁琐操作逻辑”。<br/>

![](https://static001.geekbang.org/resource/image/b6/4c/b6595844a030b8a5fab2f206006e234c.jpg?wh=4000x2636)

虽然单线程管理简单，但是因为只有一个“执行单元”，如果遇到 CPU 密集计算的执行流程，就会被阻断住，导致后续程序内容执行不了，这就是 Node.js 发生阻塞的原因。<br/>

```
// demos/http.cjs
const Koa = require('Koa');
const Router = require('@koa/router');

const app = new Koa();
const router = new Router();
const port = 9001;

router.get('/001', async (ctx) => {
  ctx.body = '<div>普通页面结果</div>';
});

router.get('/002', async (ctx) => {
  let count = 0;
  for (let i = 0; i < 9999999999; i++) {
    count++;
  }
  ctx.body = `<div>CPU密集计算数据 - 共[${count}]次计算</div>`;
});

app.use(router.routes());

app.listen(port, () => {
  console.log('服务已启动');
  console.log(`访问普通请求 http://127.0.0.1:${port}/001`);
  console.log(`访问CPU密集计算请求 http://127.0.0.1:${port}/002`);
});
```
这段代码是一个简单的 Koa.js 实现的 Node.js 服务，提供了两个 HTTP 页面，页面路径分别是 “/001”和“/002”。其中，路径“/001”请求是普通的 HTML 页面，路径“/002”请求是经过九十多亿次计算后才响应的 HTML 页面。这里，九十多亿次的计算属于 CPU 密集计算，在这个环节，Node.js 单线程服务会被阻塞住，直到被占用 CPU 的资源被释放。<br/>

我们写一个请求 HTTP 脚本，请求这两个路径，验证一下效果。
<br/>
```
// demos/http-get.cjs
// 单独请求 /001
const start = Date.now();
fetch('http://127.0.0.1:9001/001')
  .then((res) => res.text())
  .then(() => {
    console.log(`/001 请求耗时 ${Date.now() - start}ms`);
  });
```
执行之后的结果如下：
![](https://static001.geekbang.org/resource/image/f1/88/f139ccca916fe190e8bba53df3bba288.png?wh=1390x438)

可以看出，路径为“/001”普通页面请求处理，大概需要几十毫秒耗时。
<br/>

接下来换成单独请求 CPU 密集计算路径“/002”。
<br/>
```
// demos/http-get.cjs
// 单独请求 /002
const start = Date.now();
fetch('http://127.0.0.1:9001/002')
  .then((res) => res.text())
  .then(() => {
    console.log(`/002 请求耗时 ${Date.now() - start}ms`);
  });
```

执行之后的结果如下：
![](https://static001.geekbang.org/resource/image/bb/bc/bb27c5a6a5a9bafeeb2ee9624d4936bc.png?wh=1390x538)

可以看出，先请求 CPU 密集计算的“/002”路径，会阻塞住后面普通页面的“/001”路径请求，导致原本“/001”请求从耗时几十毫秒上升到十几秒，瞬间从“毫秒级”降级到“秒级”。
<br/>

由此我们可以得出一个结论，Node.js 服务中一旦出现密集计算的过程，就容易导致阻塞问题，阻塞了后续请求过程，导致并发问题。<br/>

#### 什么是进程和线程

- 进程，英文称为 Process，是计算机系统里调度和分配资源的单位，也是线程的运行的宿主容器。
- 线程，Thread，是计算机系统里运算的最小单位，在进程中运行，也是进程中实际运行程序的单位。我们经常提到的“多线程”，就是指在“同一进程”里，有“多个线程”来执行程序，并且共享“同一进程分配的资源”。

听起来有点抽象，我们还是用“发快递”的例子来类比“多进程”和“多线程”。<br/>

举个简单的例子：
- 进程，就是城市里每一个快递点，可以调度和分配快递的运力资源。
- 线程，就是快递点里的快递员，是实际快递点执行配送快递的最小单元。

线程时间可以公用资源。<br/>
进程之间虽然不能共享资源，但是可以进行进程间通信，全称 InterProcess communication，简称 IPC。
![](https://static001.geekbang.org/resource/image/0e/fd/0ef5192b94998360e43609cf298738fd.jpg?wh=4000x2636)

#### 如何使用 Node.js 的多进程和多线程

目前 Node.js 天然提供了进程和线程的控制模块，我们可以直接使用。
<br/>
想发挥多线程多进程的优势，首先要有瓶颈场景，那我们先模拟复杂的 Vue.js 服务端渲染场景。
```
// demos/html-action.js
const { h, renderList, toDisplayString, createSSRApp } = require('vue');
const { renderToString } = require('vue/server-renderer');

// Vue.js组件
const Item = {
  props: { index: Number, text: String },
  setup(props) {
    const { text, index } = props;
    return () => {
      return h('div', { class: 'v-item' }, [
        toDisplayString(index),
        toDisplayString(text)
      ]);
    };
  }
};

// Vue.js组件
const List = {
  props: {
    list: Array
  },
  setup(props) {
    const { list } = props;
    return () => {
      return h(
        'ul',
        { class: 'v-list' },
        renderList(list, (item, index) => {
          return h('li', null, [
            h('li', null, [h(Item, { text: item.text, index: index })])
          ]);
        })
      );
    };
  }
};

// Vue.js服务端渲染代码
// 按count数量，循环拼接Vue.js组件HTML字符串
async function createAppHTML(count) {
  const list = [];
  for (let i = 0; i < count; i++) {
    list.push({ text: `data-${i}` });
  }
  const app = createSSRApp(List, { list });
  const html = await renderToString(app);
  return html;
}

// 循环次数列表
const dataList = [100000, 200000, 300000, 400000];

module.exports = {
  createAppHTML,
  dataList
};
```

单进程单线程”的方式来执行，代码是这样的，
```
// demos/html.js
const { createAppHTML, dataList } = require('./html-action');

async function main() {
  const htmlList = [];
  const start = Date.now();
  for (let i = 0; i < dataList.length; i++) {
    const s = Date.now();
    const html = await createAppHTML(dataList[i]);
    htmlList.push(html);
    console.log(
      `编译数据量为 [${dataList[i]}] 的Vue模板，耗时 ${Date.now() - s}ms`
    );
  }
  console.log(`编译HTML结束，总耗时为 ${Date.now() - start}ms`);
}

main();
```

耗时结果如下：
![](https://static001.geekbang.org/resource/image/1a/19/1a8edc71f9055167daf8728285148b19.png?wh=1632x638)

单进程单线程模式下，耗时 55 多秒，CPU 使用率 96%。
<br/>
用 Node.js 多线程的方式来处理，得到新的 CPU 使用率，对比一下。
```
// demos/html-thread.js 
const {
  isMainThread,
  workerData,
  Worker,
  parentPort
} = require('worker_threads');
const { createAppHTML, dataList } = require('./html-action');

const htmlList = [];
// 线程数量为 多次密集计算的数量
const threadCount = dataList.length;

if (isMainThread) {
  // 如果是在主线程内
  console.log('Main Thread: 主线程');
  const mainStart = Date.now();
  // 触发多线程
  for (let i = 0; i < threadCount; i++) {
    // 将多次Vue.js服务端渲染的密集计算分配给子线程
    const worker = new Worker(__filename, {
      workerData: { count: dataList[i] }
    });
    // 线程间的通信
    worker.on('message', (data) => {
      htmlList.push(data.html);
      console.log(
        `Child Thread (${worker.threadId}) 子线程执行耗时：${data.time}ms`
      );
      if (htmlList.length >= dataList.length) {
        console.log(`执行全部结束，总耗时: ${Date.now() - mainStart}ms`);
      }
      // 子线程执行完计算后，触发结束子线程
      worker.emit('end');
    });
  }
} else {
  // 如果进入子线程
  // 并行帮忙执行分配的任务
  console.log(`Child Thread: 启动子线程， 初始数据：${workerData.count}`);
  const start = Date.now();
  createAppHTML(workerData.count).then((html) => {
    parentPort.postMessage({ html, time: Date.now() - start });
  });
}
```
执行结果如下：
![](https://static001.geekbang.org/resource/image/58/67/58a246dd09867c91d93fb42e3e3dfc67.png?wh=1720x838)
用多线程模式（单进程的多线程），耗时 25 秒左右，CPU 使用率达到 222%，比刚才的单线程 96% 使用率高，这是因为利用多线程，发挥了多核 CPU 的算力，得到性能的提升，提高运行速度，降低运行时间。

<br/>

多进程模式方式如下：
```
// demos/html-process.js
const cluster = require('cluster');
const { createAppHTML, dataList } = require('./html-action');

const htmlList = [];
// 进程数量为 多次密集计算的数量
const processCount = dataList.length;

if (cluster.isMaster) {
  // 进入主进程
  console.log('Main Process: 主进程');
  const mainStart = Date.now();

  for (let i = 0; i < processCount; i++) {
    // 启动多进程来并发执行任务
    const worker = cluster.fork();
    worker.send({ count: dataList[i] });

    // 进程之间的IPC通信
    // 主进程向子进程发送任务数据
    worker.on('message', (data) => {
      htmlList.push(data.html);
      console.log(
        `Child Process (${worker.process.pid}) 子进程执行耗时：${data.time}ms`
      );
      if (htmlList.length >= dataList.length) {
        console.log(`执行全部结束，总耗时: ${Date.now() - mainStart}ms`);
      }
      // 子进程执行完任务后，退出子进程
      worker.kill();
    });
  }
} else {
  console.log(`Child Process: 启动子进程 (pid: ${process.pid})`);
  // 进程之间的IPC通信
  // 接收主进程的消息
  process.on('message', (data) => {
    const start = Date.now();
    // 执行Vue.js服务端渲染的密集计算
    createAppHTML(data.count).then((html) => {
      // 通过IPC，向主进程发送消息
      process.send({ html, time: Date.now() - start });
    });
  });
}
```

执行代码，查看多进程的性能使用情况。
![](https://static001.geekbang.org/resource/image/b7/d8/b751ae6fa1e99a20868dd8ede9a1c5d8.png?wh=1720x838)
从截图可以看出，多线程执行的耗时 24 秒左右，CPU 使用率达到 143%，这是因为使用了多进程，也同样发挥了多核 CPU 的算力，得到了性能的提升。
<br/>
多进程和多线程两次运行对比，除了 CPU 使用率有差异，耗时是差不多的，而且都比单进程单线程执行的耗时少。我们归纳一下多线程和多进程的优劣。
![](https://static001.geekbang.org/resource/image/7f/1d/7f66249b9f534c63fb4b28cf433bfb1d.jpg?wh=4000x1990)
总结一下，
多线程比多进程省内存等资源，但是，多进程比多线程稳定性强一些。你可以这么理解，多线程比较适合单独解决密集计算问题，多进程较适合管理服务的稳定性。

#### 如何部署搭建平台多进程服务

从前面 Node.js 的多进程案例代码中，我们可以看出，开启多进程是直接扩展出子进程，执行 Node.js 的应用程序，不需要改动原有的应用代码。<br/>

那么面向本课程的运营搭建平台，我们可以添加这个服务进程管理文件，执行服务的多进程。<br/>

```

// packages/work-server/start.cjs
const cluster = require('cluster');
const path = require('path');
const os = require('os');

const processCount = os.cpus().length;
const entryFile = path.join(__dirname, 'dist', 'index.cjs');

cluster.setupMaster({
  exec: entryFile
});

// 根据CPU核数，启动多进程
for (let i = 0; i < processCount; i++) {
  cluster.fork();
}
```

从代码可以看出，Node.js 服务，只需要新增一个脚本来启动多进程。这里，多进程的数量，建议跟当前服务器器的 CPU 核数保持一致，能最大限度发挥多核 CPU 的资源和能力。<br/>

有一点你要特别注意，<b>多进程模式，主要在生产模式中使用，不要在开发模式下使用。</b><br/>

因为在开发模式中，我们是基于 TypeScript 语法进行代码开发，同时又有 nodemon 进行代码热更新，如果这时候开发模式加上了多进程，会带来很多开发上的干扰。而且，多进程的使用，是为了解决生产环境下的遇到服务阻塞问题或并发问题，是一种服务端性能优化的技术措施，并不是必要的技术措施。所以在课程的代码案例里，我们在生产模式中启动多进程服务。
<br/>

当然，我们基于原生 Node.js 的进程模块，启动了服务的多进程，社区也有成熟的现成工具来直接辅助启动多进程，你可以考虑使用 pm2，具体工具信息可以查看这里：[pm2](https://www.npmjs.com/package/pm2)。
<br/>

> 此文章为 4 月 Day5 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪

