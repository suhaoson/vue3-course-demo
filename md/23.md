### 运营物料的后台管理：如何全栈化实现列表分页的功能？

#### 如何设计物料管理的功能逻辑？

先梳理一下物料管理的整个功能链路需要哪些“功能点”。
<br/>
按照课程运营搭建平台的设计，我们基于“按需开发”的原则，先实现核心够用的功能，后续根据实际情况再按需扩展。<br/>

- 物料注册
- 物料编辑
- 物料列表管理
- 物料快照列表管理
  <br/>

<b>注册物料功能链路图如下:</b>
![](https://static001.geekbang.org/resource/image/09/84/092a57b56cbeb256eec8153fcacd6a84.jpg?wh=4000x2250)
<br/>
注册物料的功能逻辑有三个步骤点。<br/>

- 第一步，用户输入物料名称和版本号等信息，提交给服务端。
- 第二步，服务端对物料名称和版本进行判断处理。
- 第三步，服务端返回结果，浏览器显示结果。
  <br/>

<b>“物料编辑”的功能逻辑设计。如图：</b>
![](https://static001.geekbang.org/resource/image/80/f7/80yyb4cc09b7e480a74c44f286f03af7.jpg?wh=4000x2250)

我把物料编辑功能逻辑分成四步。<br/>

- 第一步，用户进入的物料编辑页面，渲染物料当前完整数据。
- 第二步，用户在当前数据上编辑修改后，提交新版本号给服务端。
- 第三步，服务端对物料新版本进行校验。
- 第四步，浏览器处理对应的返回结果。
  <br/>

我们基本靠列表进行显示处理，所以接下来的基本功能就是“物料列表管理”和“物料快照列表管理”。

<b>列表显示数据和分页的页码选择操作。</b>
![](https://static001.geekbang.org/resource/image/2c/65/2c479cc3074883151bd88b6807b0f665.jpg?wh=4000x2250)

分页列表具体的功能逻辑有三步。<br>

- 第一步，进入列表页面时，默认渲染第一页的列表数据。
- 第二步，渲染分页的页码选择器。
- 第三步，点击页码选择器的按钮，渲染对应页码的列表数据。

#### 如何设计物料管理的技术方案？

##### 物料注册的技术方案

<b>物料注册的技术方案图。</b>
![](https://static001.geekbang.org/resource/image/c9/c3/c9acb05b2e0927098a3f03c98a12cec3.jpg?wh=4000x2250)
<br/>
物料注册操作的技术方案分成四步。<br/>

- 第一步，前端提交“待注册”的物料名称和物料版本号。
- 第二步，服务端接收 HTTP 请求。
- 第三步，服务端处理物料注册数据。
- 第四步，浏览器处理 HTTP 响应结果。

##### 物料编辑的技术方案

<b>物料编辑流程的技术方案图。</b>
![](https://static001.geekbang.org/resource/image/ae/09/aece743fb9e941da8287a59a2a682809.jpg?wh=4000x2250)

物料编辑比物料注册复杂一些，因为涉及数据的来回请求操作。分成六步。

- 第一步，渲染编辑物料页面。物料编辑页面的 URL，携带了物料的 uuid 数据，通过 uuid 发起 GET 请求到服务端，查找详细的物料数据。
- 第二步，服务端接收请求，查询物料信息。服务端接收到 HTTP 请求，进行登录态校验，校验成功后才能进行下一个操作环节。根据 uuid 查找物料信息。最后返回物料信息给前端。
- 第三步，渲染待编辑的完整信息。如果前端拿到完整物料信息，就填充到动态表单，渲染完整的表单信息，方便给用户进行编辑，否则提示对应失败原因。
- 第四步，提交“已编辑”的物料信息，用表单格式发起 POST 请求，发送给服务端。
- 第五步，服务端接收 HTTP 请求，并处理已编辑信息。
  - 路由层进行登录态校验，校验成功后才能进行解析 HTTP 表单，把“已编辑”的物料信息提出来进行数据处理。
  - 用物料名称查询在数据库里是否为已注册物料，如果是则进入下一环节校验。
  - 校验新版本是否大于旧版版本号，同时判断编辑后的新版本，是否存在 CDN 静态资源，如果存在就进行更新物料信息数据，同时记录物料新数据到物料快照表里，记录一次物料操作变更。
- 第六步，浏览器处理 HTTP 响应结果，如果物料编辑成功，就跳转到物料列表页面。如果物料编辑失败，就提示失败原因。

<br/>
<b>列表管理的技术方案</b>
<br/>
物料列表和物料快照列表的技术方案，我们统一用一套技术方案。
<br/>

![](https://static001.geekbang.org/resource/image/bf/4f/bf77a135e6480ba29yy93b41e8b0a74f.jpg?wh=4000x2363)

列表分页查询的技术方案，分成三步。<br/>

- 第一步，首次进入列表页的默认分页渲染。这时候，请求中携带的参数有首页页码，每页数量。
- 第二步，服务接收到分页列表的请求数据后，首先要在路由层做用户登录态的校验。
- 第三步，前端接收到分页查询后的数据，把数据进行列表渲染和分页选择器渲染。

##### 如何实现物料列表分页功能？

<b>前端实现部分</b>

前端实现部分主要有两个渲染模块，“渲染列表”和“渲染页码选择器”。其中“渲染列表”非常简单，直接基于 Vue.js 的 v-for 语法，把数据进行循环渲染出来。“页码选择器”比较复杂，我们看效果图。

![](https://static001.geekbang.org/resource/image/2b/d6/2b45fbfb3efc33939be51b3f5efa2bd6.jpg?wh=4000x2250)
从图中可以看出，实现页码选择器需要三个数据，“列表数据量”“选中页码”和“数据总量”。我们可以基于“列表数据量”和“数据总量”计算得出“页数总量”，也就是页码的总数。

```
interface PageItem {
  num: number;
  text: string;
  active: boolean;
  disabled: boolean;
}

function parsePagination(params: {
  size: number;
  total: number;
  pageNum: number;
}) {
  const { size, total, pageNum } = params;
  const pageItemList: PageItem[] = [];
  const pageCount = Math.ceil(total / size);
  const pageStartNum: number = Math.max(1, pageNum - 2);
  const pageEndNum: number = Math.min(pageCount, pageNum + 2);

  for (let i = pageStartNum; i <= pageEndNum; i++) {
    pageItemList.push({
      num: i,
      text: `${i}`,
      active: i === pageNum,
      disabled: false
    });
  }
  pageItemList.unshift({
    num: pageNum - 1,
    text: '上一页',
    active: false,
    disabled: pageNum - 1 < pageStartNum
  });
  pageItemList.push({
    num: pageNum + 1,
    text: '下一页',
    active: false,
    disabled: pageNum + 1 > pageEndNum
  });
  return pageItemList;
}
```

我们可以基于“列表数据量”“选中页码”和“数据总量”，换算出可以显示的页码内容，接下来渲染页码，就可以得到页码选择器。
<br/>
对应的完整功能逻辑的 Vue.js 3.x 代码。
<br/>

```
<template>
  <div class="pagination">
    <div class="page-list">
      <span
        class="page-item"
        :class="{ active: item.active, disabled: item.disabled }"
        v-for="(item, index) in state.pageItemList"
        :key="index"
        @click="onClickPageItem(item)"
        :data-page-num="item.num"
      >
        {{ item.text }}
      </span>
    </div>
    <span class="page-info">
      ( 共{{ state.pageCount }}页， 共{{ props.totalDataCount }}条数据 )
    </span>
  </div>
</template>

<script lang="ts" setup>
import { reactive, onMounted, watch } from 'vue';

interface PageItem {
  num: number;
  text: string;
  active: boolean;
  disabled: boolean;
}

const props = defineProps<{
  pageNum: number;
  pageSize: number;
  totalDataCount: number;
}>();

const emits = defineEmits<{
  (event: 'changePage', e: { pageNum: number }): void;
}>();

const state = reactive<{
  pageItemList: PageItem[];
  pageCount: number;
}>({
  pageItemList: [],
  pageCount: 0
});

// 挂载时候进行页码计算和渲染
onMounted(() => {
  updatePagination({
    size: props.pageSize,
    pageNum: props.pageNum,
    total: props.totalDataCount
  });
});

watch(
  [() => props.pageSize, () => props.pageNum, () => props.totalDataCount],
  ([pageSize, pageNum, totalDataCount]) => {
    // 监听数据变化时候，进行页码重新计算和渲染
    updatePagination({
      size: pageSize,
      pageNum: pageNum,
      total: totalDataCount
    });
  }
);

// 点击页码的事件
const onClickPageItem = (item: PageItem) => {
  if (item.active || item.disabled) {
    return;
  }
  updatePagination({
    size: props.pageSize,
    pageNum: item.num,
    total: props.totalDataCount
  });
  emits('changePage', { pageNum: item.num });
};

// 页码数据的统一更新方法
function updatePagination(params: {
  size: number;
  pageNum: number;
  total: number;
}) {
  const { total, size } = params;
  const pageItemList = parsePagination(params);
  state.pageItemList = pageItemList;
  state.pageCount = Math.ceil(total / size);
}

// 页码的计算方法
function parsePagination(params: {
  size: number;
  total: number;
  pageNum: number;
}) {
  const { size, total, pageNum } = params;
  const pageItemList: PageItem[] = [];
  const pageCount = Math.ceil(total / size);
  const pageStartNum: number = Math.max(1, pageNum - 2);
  const pageEndNum: number = Math.min(pageCount, pageNum + 2);

  for (let i = pageStartNum; i <= pageEndNum; i++) {
    pageItemList.push({
      num: i,
      text: `${i}`,
      active: i === pageNum,
      disabled: false
    });
  }
  pageItemList.unshift({
    num: pageNum - 1,
    text: '上一页',
    active: false,
    disabled: pageNum - 1 < pageStartNum
  });
  pageItemList.push({
    num: pageNum + 1,
    text: '下一页',
    active: false,
    disabled: pageNum + 1 > pageEndNum
  });
  return pageItemList;
}
</script>
```

页码选择器最终实现效果看图。
![](https://static001.geekbang.org/resource/image/ce/e5/ceefe0fc687e1a634e1e6141bce471e5.png?wh=1592x598)
![](https://static001.geekbang.org/resource/image/d4/02/d4b486db9f03217f8979f3e404353302.png?wh=1506x850)

<b>服务端实现部分</b>

服务端部分的实现，如图：
![](https://static001.geekbang.org/resource/image/fd/yy/fd941ea63a917f2a31c58e9105ee82yy.jpg?wh=4000x2363)

<b>服务端的实现核心，就是查询数据库的 SQL 语句的实现。</b>
<br/>
前端发起分页查询请求，把“列表数据量”和“选择页码”传给服务端。在服务端中，根据每页“列表数据量”和“选择页码”进行换算，变成 SQL 查询的数据“查询起始位置”和“查询个数”，来处理数据库分页查询。

```
SELECT COUNT(*) AS total FROM table_xxxx；
```

[TODO 完整代码在这里...](../main/)<br/>

> 此文章为 3 月 Day24 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
