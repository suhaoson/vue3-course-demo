### 单页面应用：如何理解和实现单页面应用开发？

#### 什么是单页面应用？

单页面应用，英文的专业术语是 Single-Page-Application，简称“SPA”，和“多页面应用”相对。
<br/>
<b>在传统的多页面应用中，每次切换页面的跳转过程，一般分成五个阶段：</b>
<br/>

- 第一阶段，浏览器 URL 改变发起新页面的 HTTP 请求；
- 第二阶段，服务端接受到请求，通过路由响应请求的 HTML 结果；
- 第三阶段，浏览器接受到 HTML 响应并加载 HTML 结果；
- 第四阶段，浏览器等待加载 HTML 里依赖的资源（JavaScript、CSS、图片等文件）；
- 第五阶段，HTML 页面静态资源加载完后，渲染对应内容。
  <br/>
  <b>而单页面应用，每次切换页面的过程，可以缩短成两个执行阶段：</b>

- 第一阶段，浏览器 URL 改变，发起新页面静态资源请求（JavaScript、CSS、图片等文件）；
- 第二阶段，新页面资源加载完后，渲染对应内容。

<br/>
单页面应用是通过浏览器层面控制 URL，代替服务端路由进行页面跳转（或切换）的控制处理，减少 HTTP 请求，提升页面切换速度。（浏览器路由）
<b>单页面应用的核心能力就是浏览器路由能力。</b>

#### 实现浏览器路由有哪些技术方案？

浏览器实现类似功能有两种方式，
<br/>

- 一种是 URL 的 hash 值控制
- 另外是浏览器的 history 控制。

```
https://example.com/page/xxx.html?a=1&b=2#title-123
```

<br/>
URL 的 hash，传统的作用是来标记页面某个位置的锚点。<br/>
这时候，我们就可以利用这个 URL 的 hash 非锚点特性。当 hash 变化时候，用 JavaScript 监听这个变化，然后加载指定资源渲染页面，不需要重新请求服务端刷新整个页面。
<br/>

```
const viewDom = document.querySelector('#view');
const linksDom = document.querySelector('#links');
const viewMap = {
'#/': '<h1>Default View</h1>',
'#/home': '<h1>Home View</h1>',
'#/about': '<h1>About View</h1>',
'#/page/hello': '<h1>Page Hello View</h1>',
'#/page/001': '<h1>Page 001 View</h1>',
'#/page/002': '<h1>Page 002 View</h1>',
'#/404': '<h1>404 View</h1>'
};

const renderLinks = () => {
const linkList = Object.keys(viewMap);
const htmlList = [];
linkList.forEach((link) => {
htmlList.push(
`<li><a class="${
        link === location.hash ? 'active' : ''
      }" href="${link}">${link}</a></li>`
);
});
linksDom.innerHTML = htmlList.join('');
};

const renderView = () => {
// 获取当前 URL 的 hash
// 渲染对应 hash 的页面内容
const hash = window.location.hash;
const viewPath = hash.split('?')[0];
const viewHtml = viewMap[viewPath] || viewMap['#/404'];
viewDom.innerHTML = viewHtml;
};

window.addEventListener('hashchange', () => {
// 监听 URL 的 hash 变化时候
// 重新渲染页面内容
renderView();
renderLinks();
});

renderLinks();
renderView();
```

配套 HTML 代码：<br/>

```

<html>
  <head>
    <meta charset="utf-8" />
    <style>
      html,body { margin: 0; padding: 0 }
      #links {
        list-style: none;
        margin: 0;
        padding: 0 10px;
        flex-direction: row;
        display: flex;
        background: #3b889f;
      }
      #links li a {
        display: inline-block;
        padding: 10px 20px;
        font-size: 20px;
        color: #ffffff;
        text-decoration: none;
      }
      #links li a.active {
        background: #ffffff;
        color: #3b889f;
      }
      #view {
        padding: 20px;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <ul id="links"></ul>
    <div id="view"></div>
    <script type="module" src="./spa-hash-router.js"></script>
  </body>
</html>
```

![](https://static001.geekbang.org/resource/image/yy/71/yyda0a26af5bddf94573606a73ea2f71.gif?wh=600x338)
<br>
history 能通过新增一个“访问历史”来影响当前浏览器的 URL 变化，同时，这个变化的 URL 也是可以自定义的。

所以，我们可以通过 history 来实现浏览器路由，看代码：

```
const viewDom = document.querySelector('#view');
const linksDom = document.querySelector('#links');
const viewMap = {
'/': '<h1>Default View</h1>',
'/home': '<h1>Home View</h1>',
'/about': '<h1>About View</h1>',
'/page/hello': '<h1>Page Hello View</h1>',
'/page/001': '<h1>Page 001 View</h1>',
'/page/002': '<h1>Page 002 View</h1>',
'/404': '<h1>404 View</h1>'
};

const renderLinks = () => {
const linkList = Object.keys(viewMap);
const htmlList = [];
linkList.forEach((link) => {
htmlList.push(
`<li>
        <a class="${
          link === location.pathname ? 'active' : ''
        }" href="javascript:void(0)" data-href="${link}">${link}</a>
      </li>`
);
});
linksDom.innerHTML = htmlList.join('');
};

const renderView = () => {
const viewPath = window.location.pathname;
const viewHtml = viewMap[viewPath] || viewMap['#/404'];
viewDom.innerHTML = viewHtml;
};

// 人工注册 history 路由的 pushState 和 replaceState 监听
// 因为浏览器原生不支持
function registerHistoryListener(type) {
const originFunc = window.history[type];
const e = new Event(type);
return function () {
const result = originFunc.apply(this, arguments);
e.arguments = arguments;
window.dispatchEvent(e);
return result;
};
}

// 人工实现 history 路由的 pushState 事件监听
history.pushState = registerHistoryListener('pushState');
// 人工实现 history 路由的 replaceState 事件监听
history.replaceState = registerHistoryListener('replaceState');

// 监听 history 路由 pushState
window.addEventListener('pushState', () => {
renderLinks();
renderView();
});
// 监听 history 路由 replaceState
window.addEventListener('replaceState', () => {
renderLinks();
renderView();
});

linksDom.addEventListener('click', (e) => {
// 链接点击之间时候
// 拦截事件，然后做 history 跳转操作
const dom = e.target;
const dataHref = dom.getAttribute('data-href');
if (dataHref) {
history.pushState({}, '', dataHref);
}
});

renderLinks();
renderView();
```

![](https://static001.geekbang.org/resource/image/03/26/03418027cccdc83dac85c9bdb27eba26.gif?wh=600x338)
在实际开发中，hash 路由和 history 路由最大的差异就是浏览器兼容的差异。hash 路由是利用浏览器传统的 URL hash 锚点能力，这个特性，绝大部分浏览器都兼容;
![](https://static001.geekbang.org/resource/image/54/f7/54afcb63571c3bfdea4c503b8a4f1df7.png?wh=2874x1548)
![](https://static001.geekbang.org/resource/image/ac/a9/ac3c11461b6770553fdc6a278b9b3aa9.png?wh=2874x1616)
<br/>

除了浏览器这个兼容性差异，它们对页面所在服务端的要求也不同。hash 路由只改变 URL 的 hash 值，当前页面强制浏览器刷新时，还能保持在当前页面。但是，history 路由是真的改变了浏览器 URL 的路径 path，当前页面强制浏览器刷新时，要走一遍服务器请求，查询当前 URL 是否存在，所以要保持 history 路由改变的 URL 存在，服务器路由就必须跟前端路由同步。

#### Vue.js 3.x 如何实现完善的单页面应用？

<b>如何基于 vue-router，实现常见的单页面应用的需求场景。</b>

常见的功能场景主要有这么四种，我们会通过 vue-router 逐一实现：<br/>

1. hash 路由（面向兼容 IE8 等低版本浏览器）
2. history 路由（面向高版本浏览器和优雅 URL 路由）
3. 动态路由和嵌套路由（动态 URL 和多级 URL）
4. 主动路由跳转（代码主动触发页面跳转）
   <br/>

5. hash 路由
   以 hash 路由形式，实现基本的单页面应用功能，具体代码如下所示

```
import { createRouter, createWebHashHistory } from 'vue-router';
import { createApp } from 'vue';
// 主应用
import App from './app.vue';

// 不同路由的页面视图
import HomeView from './views/home.vue';
import ListView from './views/list.vue';
import AboutView from './views/about.vue';

// 定义路由
const router = createRouter({
  linkActiveClass: 'active',
  // hash 路由配置
  history: createWebHashHistory('/'),
  routes: [
    {
      path: '/',
      name: 'home',
      component: HomeView
    },
    {
      path: '/list',
      name: 'list',
      component: ListView
    },
    {
      path: '/about',
      name: 'about',
      component: AboutView
    }
  ]
});

const app = createApp(App);
app.use(router);

app.mount('#app');

```

代码中， RouterLink 是 vue-router 提供的单页面应用链接组件，RouterView 是对应链接的视图，更多使用概念你可以查看官网。
<br/>
具体的执行过程就是，创建 hash 路由到注册路由页面，再挂载到前端应用上。
<br/>

2. history 路由

```

// 定义路由
const router = createRouter({
  // 其它代码 ...

  // hash 路由配置
  // history: createWebHashHistory('/'),

  // history 路由配置
  history: createWebHistory('/'),

  // 其它代码 ...
}
```

3. 动态路由和嵌套路由
   看路由配置代码，我用注释指明了动态路由和嵌套路由。动态路由是用“:”开头的变量，来标明路由中的动态数据。嵌套路由，是在路由里使用 children 来承载一个新的路由数组，作为当前路径后“接上”的子路由：

```

// 定义路由
const router = createRouter({
  // 其它配置 ...
  routes: [
    // 动态路由
    {
      path: '/detail/:id',
      component: DetailView,

      // 嵌套路由
      children: [
        { path: '', component: DetailItemView }
      ]
    }
  ]
```

这里，动态路由的“:id”数据，可以在对应 View 的组件里通过 $route.params.id 拿到对应数据，例如 /detail/A001 可以得到 $route.params.id = "/detail/A001"。同时，动态路由里的子路由页面，会渲染内部的 component 组件。4

4. 主动路由跳转

   虽然 vue-router 提供了 RouterLink 组件来承载路由连接，但是这个组件需要人为点击才能触发路由跳转，无法实现代码主动触发跳转。所以， vue-router 又提供另外一个 API，也就是 useRouter 让开发者能主动操作路由实体，例如可以触发路由跳转等。
   <br/>

具体代码实现如下所示：

```

import { useRouter } from 'vue-router';

const router = useRouter();

const onClick = () => {
  router.push('/list');
};
```

#### 如何优雅扩展的单页面应用？

答案就是按需加载。我们可以把每个子页面资源独立打包，当主页面切换到子页面时，按需加载对应子页面的 JavaScript 和其他资源。
<br/>
具体实现：

```

const router = createRouter({
  linkActiveClass: 'active',
  // hash 路由配置
  // history: createWebHashHistory('/'),

  // history 路由配置
  history: createWebHistory('/'),
  routes: [
    {
      path: '/',
      name: 'home',
      component: () => import('./views/home.vue')
    },
    {
      path: '/list',
      name: 'list',
      component: () => import('./views/list.vue')
    },
    {
      path: '/about',
      name: 'about',
      component: () => import('./views/about.vue')
    },
    {
      path: '/detail/:id',
      component: () => import('./views/detail.vue'),
      children: [
        { path: '', component: () => import('./views/detail-item.vue') }
      ]
    }
  ]
});
```

这里，import 动态加载子模块后，Vite 在生产模式构建时，会分割对应代码文件，最终生产环境也能实现单页面应用动态加载模块。如果你使用 Webpack 编译项目，也可以配置类似的构建结果，根据 import 来动态分割代码文件。

<br/>

<b>数据隔离</b>、<b>样式隔离</b>
<br/>
数据隔离，就是防止全局变量泛滥或者污染。在实际项目中，我们可以规范每个子页面开发过程，禁止操作 window 的全局变量。如果真的需要借助全局变量进行操作，你可以在每个子页面操作全局变量时，加个唯一的前缀，同时，离开页面时清理原有全局变量的内容，防止内存泄露。
<br/>
样式隔离，就是防止样式污染。如果子页面是通过 Vue.js 模板语法开发的，你可以加上 scoped 属性保证每个子页面的样式都是唯一不冲突，或者，对每个子页面约定一个唯一的 className 前缀。

> 此文章为 3 月 Day17 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
