### 物料组件的编译和管理：如何处理组件的多种模块格式？

“物料”功能，核心就是操作物料的静态资源和数据库数据。其中，物料静态资源指的是每个物料组件的产物，也就是 JavaScript 和 CSS 文件，可以独立在浏览器或者 Node.js 环境中进行渲染或者执行。
<br/>
而运营搭建平台，底层功能里最核心就是用物料搭建页面。<br/>
如何搭建，其实就是把这些物料的 JavaScript 和 CSS 文件组装起来运行。用前端技术视角看，就是用组件（物料）来组装页面。<br/>

#### 前端组件有哪些模块化方案？

- ESM 模块化方案
  这个 ES 官方规范的模块化方案，在高版本浏览器和高版本 Node.js 环境下才能直接使用。
  <br/>
  兼容问题
- AMD 模块化方案
  AMD，全称是 Asynchronous Module Definition，“异步模块定义”，是一种面向浏览器运行的模块化方案。AMD 在 ES6 还没出现之前，是 ES5 环境下常见用的模块化方案。
  <br/>
  AMD 只是一种规范，具体实现需要根据规范，实现其运行时。
  <br/>
  RequireJS，是一种 AMD 模块化规范的代码实现，看定义过程。
  ```
    define('模块id', [
    // 模块依赖id
    ], function( /*模块依赖的获取*/ ) {
    // 模块主体代码
    })
  ```
- IIFE（全局变量）模块化方案
  IIFE，全称是 Immediately Invoked Function Expression，“立即执行函数”的意思。如果要实现模块化，就需要在 IIFE 中，把代码挂载在全局变量上。
  <br/>
  这也是早期 JavaScript 的模块化方案，根据不同环境，把模块全部挂载在对应环境的全局变量上，浏览器就挂载在“window”对象上，Node.js 就挂载在 global 全局变量上。
- CJS 模块化方案
  CJS，全称是 CommonJS 模块化规范，目前用的比较广泛是在 Node.js 环境里，因为 Node.js 刚诞生的时候，模块化方案是基于 CommonJS 规范来实现的，而且，CJS 规范也是在 ES6 草案确定之前诞生的、兼容 ES5 的环境。
  <br/>
  CJS 比较适合在 Node.js 环境中使用，在 Node.js 服务端中拼接物料产物，在服务端组装成页面的 HTML。

![](https://static001.geekbang.org/resource/image/f7/40/f7c62dce3e186255d8ed29fc95f3c440.jpg?wh=1920x1385)

#### Vue.js 组件如何编译成多种模块？

目前主流的构建工具，比如 Webpack、Rollup 和 Vite，都可以基于其插件体系，来把 TypeScript 的 Vue.js 组件编译成多种模块化格式文件。我们这里使用 Vue.js 官方标配的构建工具 Vite。
<br/>
其实 Vite 底层生产模式是基于 Rollup 来进行编译的，我们可以强行传入 AMD 的配置来执行编译。看具体配置代码。

```
// scripts/build-materials.ts
import { build } from 'vite';
import pluginVue from '@vitejs/plugin-vue';
import pluginVueJsx from '@vitejs/plugin-vue-jsx';
import { resolvePackagePath, readFile } from './util';
import type { InlineConfig } from 'vite';

function getBuildConfig(opts: {
  name: string;
  version: string;
  dirName: string;
  libName: string;
}): InlineConfig {
  const { dirName, libName } = opts;
  const config: InlineConfig = {
    plugins: [pluginVue(), pluginVueJsx()],
    build: {
      target: 'esnext',
      minify: false,
      emptyOutDir: true,
      outDir: resolvePackagePath(dirName, 'dist'),
      lib: {
        name: libName,
        entry: resolvePackagePath(dirName, 'src', 'index.ts'),
        formats: ['es', 'cjs', 'iife'],
        fileName: (format) => {
          if (format === 'es') {
            format = 'esm';
          }
          return `index.${format}.js`;
        }
      },
      rollupOptions: {
        preserveEntrySignatures: 'strict',
        external: ['vue', '@vue/components'],
        output: {
          globals: {
            vue: 'Vue',
            '@vue/components': 'MyVueComponents'
          },
          assetFileNames: 'index[extname]'
        }
      }
    }
  };
  return config;
}

function getBuildAMDConfig(opts: {
  name: string;
  version: string;
  dirName: string;
  libName: string;
}): InlineConfig {
  const { dirName, name, libName } = opts;
  const config: InlineConfig = {
    plugins: [pluginVue(), pluginVueJsx()],
    build: {
      // target: 'esnext',
      minify: false,
      emptyOutDir: false,
      outDir: resolvePackagePath(dirName, 'dist'),
      lib: {
        name: libName,
        entry: resolvePackagePath(dirName, 'src', 'index.ts'),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        formats: ['amd'],
        fileName: () => {
          return 'index.amd.js';
        }
      },
      rollupOptions: {
        preserveEntrySignatures: 'strict',
        external: ['vue', '@vue/components'],
        output: {
          name: name,
          format: 'amd',
          amd: {
            id: name
          },
          globals: {
            vue: 'vue',
            '@vue/components': '@vue/components'
          },
          assetFileNames: 'index.amd[extname]'
        }
      }
    }
  };
  return config;
}

async function main() {
  console.log('执行物料编译...');
  const materialList = [
    {
      name: require('../packages/material-product-list/package.json').name,
      version: require('../packages/material-product-list/package.json')
        .version,
      dirName: 'material-product-list',
      libName: 'MyMaterialProdcutList'
    },
    {
      name: require('../packages/material-banner-slides/package.json').name,
      version: require('../packages/material-banner-slides/package.json')
        .version,
      dirName: 'material-banner-slides',
      libName: 'MyMaterialBannerSlides'
    }
  ];
  for (const opts of materialList) {
    console.log(`开始编译物料 ${opts.dirName}`);
    const config = getBuildConfig(opts);
    const configAMD = getBuildAMDConfig(opts);
    await build(config);
    await build(configAMD);
  }
}

main();

```

#### 如何管理和运行各种模块化的物料组件？

- 第一步，把物料的 Vue.js 组件编译多种模块化格式。
- 第二步，把各种模块化文件发布到私有 NPM 站点或者 CDN 服务。
- 第三步，前台和后台服务各自读取 CDN 上的物料，进行拼接页面。
- 第四步，实现各种模块化代码执行的运行时。

![](https://static001.geekbang.org/resource/image/b9/11/b9f3ca16a6473e31fbf486a53a0b8111.jpg?wh=1920x1033)

> 此文章为 3 月 Day23 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
