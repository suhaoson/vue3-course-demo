### 代码单元测试：如何轻松地保证自己的代码质量？

组件库代码的“稳定性”和“健壮性”是非常重要的。我们可以使用“单元测试”，通过技术的手段来自动化“测试代码”。<br/>

#### 什么是单元测试？

单元测试，英文是 Unit Test，也可以称之为“模块测试”，主要是对代码最小单位逐一进行测试验证功能。这里的“代码最小单位”可以是一个函数、一个组件、一个类，甚至是一个变量。只要是能执行功能的代码模块，都可以称之为一个“最小单位”。<br/>
单元测试里的“单元”，是代码里可以执行的“单位”，测试就是验证这个最小单位的代码执行完后的结果是否符合预期。
<br/>
举个例子，如果我们要开发一个数学加减乘除的功能代码，加法函数就是其中一个可执行的最小单位：

```
// 这是一个加减乘除的函数集合对象
const myMath = {

  // 这里加法函数，可以当做是最小的测试单位
  add(num1, num2) {
    return num1 + num2;
  },

  subtract(num1, num2) {
    return num1 - num2;
  },

  multiply(num1, num2) {
    return num1 * num2;
  },

  divide(num1, num2) {
    return num1 / num2;
  }
};
```

<br/>
这时候，要对加法函数这个“单元”进行单元测试，如果测试成功，就输出成功提示，如果测试失败，也就是测试结果不符合预期，就抛出错误（throw Error）。如下：

<code>
const result = myMath.add(1, 2);
const expect = 3;
if (result === expect) {
  console.log('myMath.add 加法测试成功！');
} else {
  throw Error(
    `myMath.add 加法测试失败，期待结果应该是：${expect}，但实际结果为：${result}`
  );
}
</code>

上述代码在 Node.js 环境里测试成功的效果，如下图所示：
<br/>
![](https://static001.geekbang.org/resource/image/ae/0b/ae98406a6cb05b136baf98f67e9e660b.png?wh=1456x488)
<br/>
这时候，如果我们将 expect 变量修改一下，期待值就不符合预期，触发测试失败，报错效果如下：<br/>

![](https://static001.geekbang.org/resource/image/7a/a1/7aeyy3a2787b8295d6765d9a235d14a1.png?wh=1676x888)

不过，上述测试代码使用 throw Error，会中断 JavaScript 的执行流程。如果我们要测试所有方法，并且要收集结果，也要 throw 出错误，那可以这么实现一个最简单的单元测试管理方法，代码如下所示：

```

const allUnitTestResults = [];
function unitTest(name, callback) {
  let success = false;
  let error = null;
  try {
    callback();
    success = true;
  } catch (err) {
    error = err;
  }
  allUnitTestResults.push({
    name,
    success,
    error
  });
}

unitTest('加法函数 add', () => {
  const result = myMath.add(1, 2);
  const expect = 3;
  if (result === expect) {
    console.log('myMath.add 加法测试成功！');
  } else {
    throw Error(
      `myMath.add 加法测试失败，期待结果应该是：${expect}，但实际结果为：${result}`
    );
  }
});

unitTest('减法函数 subtract', () => {
  const result = myMath.subtract(3, 2);
  const expect = 1;
  if (result === expect) {
    console.log('myMath.add 减法测试成功！');
  } else {
    throw Error(
      `myMath.add 减法测试失败，期待结果应该是：${expect}，但实际结果为：${result}`
    );
  }
});

let successCount = 0;
let failCount = 0;
allUnitTestResults.forEach((item) => {
  if (item.success === true) {
    successCount++;
  } else {
    failCount++;
    console.log(item.error);
  }
});

console.log(`总共 ${allUnitTestResults.length}个测试用例`);
console.log(`测试成功个数： ${successCount}`);
console.log(`测试失败个数： ${failCount}`);
```

运行结果如下：
![](https://static001.geekbang.org/resource/image/10/dc/106dd28a7640b834e83ca9d16a01d4dc.png?wh=1544x638)
<br/>
接下来我们就来看看前端单元测试都要准备什么工具？

#### 前端单元测试需要用什么工具？

我们先来看下，前端单元测试有什么必备的要素。前面的“数学加减乘除”功能代码的测试实现，可以分成三个过程：

- 第一步：“输入”要执行的单元代码，等带执行完的“输出”结果；
- 第二步：执行后的“输出”进行“断言”，这里的“断言”就是指结果是否符合预期；
- 第三步：逐个收集所有单元测试结果，并做最后的统计处理。
  <br/>
  目前，市面支持测试“断言”或“测试管理”的主流前端 JavaScript 单元测试工具，有 Mocha、Jest 和 Vitest：
- Mocha 是面向 Node.js 环境的 JavaScript 单元测试，不能直接支持浏览器的 API，断言可以使用 Node.js 自带 assert 模块或者第三方断言工具，例如 Chai；
- Jest 是同时支持 Node.js 和在 Node.js 里模拟浏览器 API 的测试工具，内部自带测试“断言”和“管理”工具，是 React.js 官方维护的测试工具。
- Vitest 跟 Jest 一样，都能支持 Node.js 和浏览器 API，也自带测试“断言”和“管理”工具，是 Vue.js 官方维护的测试工具，对 Vue.js 的支持能力比较友好。

#### 如何用 Vitest 给 Vue.js 3.x 组件库做单元测试？

先来看第一步，安装相关 npm 模块依赖：

```
# 基于 npm 安装
npm i -D vitest @vue/test-utils @vitejs/plugin-vue @vitejs/plugin-vue-jsx jsdom

# 或者基于 pnpm 来安装
pnpm i -D vitest @vue/test-utils @vitejs/plugin-vue @vitejs/plugin-vue-jsx jsdom
```

<br/>
第二步，在安装依赖后，我们就需要做 Vitest 的项目配置。先在项目根目录创建文件 ./vitest.config.js：

```
import { defineConfig } from 'vitest/config';
import PluginVue from '@vitejs/plugin-vue';
import PluginJsx from '@vitejs/plugin-vue-jsx';
export default defineConfig({
  // 配置插件，用来在测试过程中编译Vue.js的模板语法和JSX语法
  plugins: [PluginVue(), PluginJsx()],
  // 配置测试环境，支持全局变量和浏览器DOM API
  test: {
    globals: true,
    environment: 'jsdom'
  }
});
```

<br/>

然后在根目录的 ./package.json 添加测试脚本：

```
{
  // ...
  "scripts": {
    // ...
    "test": "vitest",
    "test:update": "vitest --update",
  }
  // ...
}
```

<br/>

现在我们可以开始来写一个单元测试，例如新建文件 ./packages/components/\*\*tests\*\*/demo.test.ts，小试一下单元测试:

```
import { describe, test, expect } from 'vitest';

describe('Demo', () => {
test('Test case', () => {
const a = 1;
const b = 2;
expect(a + b).toBe(3);
});
});
```

<br/>

执行测试命令 npm run test，vitest 会自动识别当前项目中所有 \\\*.test.ts 的测试文件进行执行测试，统计测试结果最后反馈出来，具体效果如下所示：
![](https://static001.geekbang.org/resource/image/f3/5e/f3bc0f3811aff75139yycd026e7b945e.png?wh=1544x988)

#### Vue.js 组件的场景

- 渲染测试场景；
  渲染测试场景，主要是验证 Vue.js 组件渲染后的 DOM 结构是否符合预期，也就是组件在渲染后的 HTML 结构是否符合预期，一般会直接用“<b>快照比对</b>”的方式进行断言。<br/>

  总是这么生成快照、对比快照，有需要就要更新快照，这个操作有点繁琐，还有其他的渲染测试方法吗？<br>
  答案是有的。这个测试的“输入”是组件，“输出”是快照，“断言”是快照，所以只要从“输入”、“输出”和“断言”这三个因素入手调整就行了。渲染测试，就是要看 DOM 或者 HTML 结构是否符合预期，那么我们可以选择一些重要的 DOM 或 HTML 标签，作为断言标准。

- 行为测试场景；<br/>
  行为测试场景，主要是验证 Vue.js 组件渲染后，在用户行为操作 DOM 后触发的 DOM 结构的变化。例如，用户点击了组件的按钮，触发了组件内部其他渲染变化，这个时候“输入”是组件和行为操作，“输出”是变化后的 DOM 结构，“断言”是<b>判断变化后的 DOM 结构快照或者 DOM 变化指标</b>。
- 请求测试场景；<br/>
  请求测试场景，比较特殊，主要适用于组件内部有涉及请求数据，例如图片请求的情况。那么在单元测试的流程里，“输入”就是组件和数据请求，“输出”就是数据请求结果，“断言”就是<b>判断请求结果是否符合预期</b>。
- 兜底测试场景。<br/>
  兜底测试场景，就是要做前面三个场景都无法覆盖全面的活，利用 Vitest 的模拟浏览器环境，用 Vue.js 传统渲染方式作为“输入”，“输出”是一张在 Node.js 环境里模拟浏览器里的页面，“断言”就是判断在这个“<b>模拟页面</b>”上是否存在我们想要的结果指标。

#### 单元测试覆盖率

单元测试覆盖率，指的是在被测试的代码中，被执行的代码占所有代码的比例。我们可以通过这个指标，找出哪些代码还没被测试覆盖到，避免出现功能逻辑分支被遗漏的问题。用来衡量单元测试的质量。
<br/>

测试覆盖率一般有四个指标：

- 状态覆盖率；
- 代码行数覆盖率；
- 逻辑分支覆盖率；
- 方法覆盖率。

> 此文章为 3 月 Day15 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
