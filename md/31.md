### 前台页面的日志监控：如何进行页面实时监控与问题定位？

#### 日志是什么？

在计算机领域中，程序在运行过程产生的异常错误、运行状态和操作行为等数据，就可以称为日志。不过，日志只是一种技术概念，没有明确规定的技术实现，只要能记录和存储数据的技术操作，都可以称为日志技术。
<br/>

日志数据在记录和存储后，不一定会永久存储。避免日志数据无限产生，一般会执行滚动式覆盖，或是系统设置定时任务，自动清理日志数据或手动定时清理。
<br/>

总的来说，日志的核心功能逻辑，我们可以归纳成三点。<br/>

- 上报日志
- 存储日志
- 清洗日志

![](https://static001.geekbang.org/resource/image/d5/92/d5b40c16fdba5f2db5fa8afa2cb88292.jpg?wh=5287x3048)

#### 为什么需要日志？

从日志的特点可以看出，日志功能的本质作用是记录程序运行时候的状态数据，可以是技术的状态，可以是业务逻辑的状态，没有明确的规范限制。
<br/>

有了程序运行时候的状态数据，我们就能开展很多扩展工作，通常可以归纳成三类：<br/>

- 排查问题<br/>
  排查问题，指的是可以基于日志数据来辅助排查问题，尤其是一些偶现且无规律的问题，比如员工用户在搭建页面的时候，出现报错导致生成页面失败，但是重试几下成功了。这个问题的棘手点，就是搭建页面报错情况出现很偶然且无规律，同时需要多次重试才能成功。
  <br/>
  配合日志， 辅助排查线上问题。
- 问题预警<br/>
  第二类工作内容，问题预警，就是可以定时地清洗归纳日志数据，分析程序是否存在问题爆发的可能性，并且做出预警。
  <br/>
  假设我们发布了搭建的页面给外部客户使用，如果页面出现问题，一开始只有少数客户使用功能受到影响，后来越来越多客户使用不了页面，就可能演变成生产故障。<br/>
  对于这种比较隐蔽的问题，我们可以通过监控日志，监控问题的变化趋势，快速进行页面回滚操作。
- 数据挖掘<br/>
  第三类工作内容，数据挖掘，分析日志数据的内容，提取有业务或者技术价值的直接内容或间接内容。
  <br/>
  通过分析日志中用户行为数据，归纳用户行为，并推测有哪些可挖掘的信息点。

#### 如何实现上报和存储日志？

##### 1. 前端场景

前端场景里，通用数据上报，主要基于全局事件的监听。例如监听页面全局错误事件，一旦页面发生异常错误，就会被监听的方法捕获，然后我们用 HTTP 请求，把错误数据传递给服务端进行记录。

```
// packages/portal-server/src/public/static/page-helper.js
window.addEventListener('error', (err) => {
  // 上报异常日志
  fetch('/api/log/push', {
    body: JSON.stringify({
      type: 'error',
      message: { errorMessage: err.message }
    }),
    headers: {
      'content-type': 'application/json'
    },
    method: 'POST'
  });
});
```

前端场景里，业务数据上报，主要是要根据业务的需求，编写特定的代码，收集特定的业务逻辑数据，最后也是用代码来触发上报日志。
<br/>
课程项目收集搭建页面流量来源和去向，就是一种业务需要的数据，需要编写特定的代码逻辑，收集数据来上报。比如，课程项目代码案例中，跟踪前台页面流量的上报日志代码。
<br/>

```
// packages/portal-server/src/public/static/page-helper.js
window.addEventListener('DOMContentLoaded', () => {
  // 进入页面时候，上报日志，记录“上游页面链接”
  fetch('/api/log/push', {
    body: JSON.stringify({
      type: 'track',
      message: '',
      currentLink: window.location.href,
      trackPrevLink: document.referrer, // 上游页面链接
    }),
    // ...
  });

  const body = document.querySelector('body');
  // 监听页面所有点击前的操作
  body.addEventListener('click', (event) => {
    let currentTarget = event.target;
    // 检查点击DOM是否为<a>标签
    while (currentTarget.parentElement) {
      // 判断是否为<a>标签，且存在跳转链接
      if (currentTarget.nodeName === 'A') {
        // 要跳转的下游页面链接
        const url = currentTarget.getAttribute('href');
        if (url) {
          // 上报日志，记录“下游页面链接”
          fetch('/api/log/push', {
            body: JSON.stringify({
              type: 'track',
              message: '',
              currentLink: window.location.href,
              trackNextLink: url,
            }),
            // ...
          });
          // 拦截<a>标签默认点击跳转操作
          event.preventDefault();
          // 延时人工代码触发跳转到下游页面
          // 为了保证上报日志请求能发送成功
          setTimeout(() => {
            window.location.href = url;
          }, 200);
          break;
        }
      }
      currentTarget = currentTarget.parentElement;
    }
  });
});
```

这段代码分成两个部分，上报页面流量来源日志，监听和收集页面流量去向日志。<br/>

- 第一步，等待加载页面成功，收集上游页面的链接，上报流量来源的日志数据；
- 第二步，监听页面所有 &lt;a&gt; 标签的点击事件，一旦 &lt;a&gt; 标签被点击，就判断是否有 href 属性内容，也就是要跳转的下游页面的链接；如果准备跳转，就上报要跳转的目标页面链接，作为流量去向的日志。
  <br/>
  以上代码实现属于技术开发层面的约定规范。

##### 2. 服务端场景

服务端场景里，日志收集和上报比较简单。无论是通用数据上报，还是业务数据上报，常见技术操作，都是直接在对应逻辑代码中，编写上报日志代码。
<br/>
课程案例代码在 monorepo 的项目里，创建了一个子项目 mock-logger，来模拟统一的日志读写操作。如果要在服务端上报日志，可以这样使用代码：

```
import { writePortalFrontLog } from '@my/mock-logger';

// 在需要的上报日志的服务端逻辑中
// 进行日志上报
writePortalFrontLog(logData);
```

这段代码，就是基于 Node.js 的文件系统 API，把日志数据写本地磁盘文件里（更详细的代码实现，可以看[代码案例](../main/)）。
<br/>

##### 日志存储

完成了日志数据的上报，下一步就是日志数据的存储操作，也就是“存储日志”。<br/>
开头我们讲过，日志功能没有具体的技术实现规范，只要能收集和存储日志数据就行。目前，企业常见记录日志的技术实现都是在服务器里，就近写在本地磁盘文件中。
<br/>
存储日志是高频操作，必然会产生大量的数据，如果都放在一个日志文件里，数据的读取和查询会很不方便，所以，一般写数据到日志文件时，我们会按约定的文件格式独立记录。例如按日期格式来创建每天的日志文件，每个日志文件都只记录当天的日志数据（课程的记录数据文件格式，就是按每天的维度来独立记录）。
<br/>
定期清洗数据，保留有需要的日志数。存数据库。

##### 如何清洗日志数据？

“清洗日志”的具体技术内容，通常是读取日志文件里的数据，然后过滤出有需要的内容，存储到数据库里，长期保存。
<br/>

课程的案例中，是对页面流量日志数据进行清洗，然后存到数据库的日志表里。具体的清洗逻辑就是，先判断流量日志是否为有效数据，如果是，就过滤提取出来，批量存储到数据库的日志表里，最后删除掉已清洗过的日志文件，腾出磁盘空间。

#### 如何监控页面流量的来源和去向？

![](https://static001.geekbang.org/resource/image/7b/ee/7bd22de9a581032618742a3524055eee.jpg?wh=5287x3048)

看方案图，分成四个实现步骤。<br/>

- 第一步，在前台页面中，监听页面统一的错误异常事件。
- 第二步，上报和存储日志，把日志数据通过 HTTP 方式传递到服务端，写在磁盘文件中。
- 第三步，清洗日志，提取需要长期存储的日志数据，转移到数据库中。
- 第四步，在后台日志管理页面中，提供永久日志数据查询操作。

<br/>
最终效果图：<br/>
![](https://static001.geekbang.org/resource/image/a7/30/a7a71d3eee87cbf04fe3db56eb7ca030.png?wh=1920x1145)
我在前台页面上触发一个错误，就会发起一个日志请求。

![](https://static001.geekbang.org/resource/image/4e/5c/4ec44f61b7dd4634dbcea596f9a5435c.png?wh=1920x995)

![](https://static001.geekbang.org/resource/image/c8/1c/c8b0a09083263a9a13d67cc4a417681c.png?wh=1920x1021)
<br/>
接着，在后台日志管理界面清洗日志，然后查询数据库的永久日志数据，看看近期页面有哪些前端页面报错日志。

![](https://static001.geekbang.org/resource/image/1d/95/1d7f81c7b4391bb8e19366b927526695.png?wh=1920x1259)

<br/>
通过日志功能，监控页面错误异常，我们就实现完成了，接下来看第二个功能点，通过日志功能，监控页面流量的来源和去向。

#### 如何监控页面流量的来源和去向？

![](https://static001.geekbang.org/resource/image/4a/03/4a0fac234db5a1805c8ffdcb49158103.jpg?wh=5287x3048)

实现步骤可以归纳成四步。<br/>

- 第一步，进入前台页面时候，上报和存储上游页面数据。
- 第二步，要跳出前台页面的时候，上报和存储即将去往的下游页面数据。
- 第三步，清洗日志，把有效日志数据批量存入数据库。
- 第四步，在后台页面管理中，提供根据页面来查询日志上下游流量数据。

<br/>
最后实现效果图。<br/>

![](https://static001.geekbang.org/resource/image/5c/7a/5c5c26146c3540aef73a2debbfed4f7a.png?wh=1920x721)
![](https://static001.geekbang.org/resource/image/63/ba/6340cbd6bb57b723d9b80005a8eb52ba.png?wh=1920x1049)

我先搭建一个页面，进入页面或离开页面的时候，发起日志上报请求。

![](https://static001.geekbang.org/resource/image/99/47/999b26c43dc7bc15ca7d1d257fc1d347.png?wh=1920x962)

最后进行页面流量的数据挖掘，也就是分析数据库里的日志数据（更具体的代码实现，你可以查看[代码案例](../main/)）。

<br/>

> 此文章为 4 月 Day1 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
