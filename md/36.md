### 日志收集与问题排错：如何守护好Vue.js和Node.js的全栈项目？

运营平台搭建实现完功能需求后，接下来的主要工作有两大部分。<br/>
- 功能扩展
- 功能维护
<br/>

#### 如何理解搭建平台的功能维护

“功能维护”在本应用场景下，主要的功能操作可以分成这样三类。
1. 依赖升级维护<br/>
  依赖升级维护，主要是定期对 Node.js 版本、项目依赖的 npm 模块做升级，以及升级后的代码兼容处理。<br/>
  定期维护更新Node.js版本
  其它 npm 模块的版本情况也类似，我们要定期查询最新 npm 的更新状态，然后做好升级工作和兼容测试工作。
2. 全栈问题处理<br/>
  功能维护操作的第二个内容就是全栈问题处理，可以分成两个部分，问题收集和处理问题。
3. 系统稳定运维<br/>
  功能维护操作的最后一点，系统稳定运维，主要是维持系统长时间稳定运行，保证系统的高可用性。<br/>
  
  
总的来说，第一点“依赖升级维护”就是日常环境和模块的升级迭代。后两点“全栈问题处理”“系统稳定运维”其实目标是一致的，实际工作内容也基本一致，都是保证整个系统和服务应用的高可用性。
  
#### 为什么前端程序员要懂运维工作

先给出答案，作为前端程序员，我们需要懂系统运维。站在项目和企业的综合视角上看，有三个关键因素。<br/>

1. 全栈项目包括了服务端内容。
2. 企业分工现状的局限，开发也即运维。
3. 项目技术的第一责任人划分。

<br/>

#### 搭建平台的系统运维需要关注什么

对于我们前端程序员来讲，系统运维的关注点有三个。<br/>

1. 机器配置
2. 机器资源使用情况
3. Node.js 服务的健康情况

<br/>
前二点机器配置、机器资源使用情况，我们其实可以通过服务器或云服务厂商提供的运维数据、运维建议和运维工具来管理。第三个关注点，Node.js 服务的健康情况，就需要程序员做一些开发工作，来辅助 Node.js 服务的健康状况的维护，这个工作就是我们接下来要学习的——检查 Node.js 服务健康状况。<br/>

#### 如何检查 Node.js 服务健康状况

Node.js 服务健康状况的检查，主要就是检查 Node.js 服务进程的资源使用情况。其中，最基本的内容就是进程的内存和 CPU 使用数据，通常有两种方式。
<br/>

1. Node.js 服务自己检查自己
2. 用系统工具来检查 Node.js 服务

#### 如何判断和记录进程异常快照日志

1. 第一步，判断进程异常状态。
2. 第二步，记录进程状态快照。

#### 如何进行 Node.js 进程守护操作

进程守护，不是保护进程一直稳定不中断或者崩溃，而是让进程数量一直保持在指定的数量。
<br/>

看具体代码案例。
```
// packages/work-server/start-daemon.cjs
const path = require('path');
const cluster = require('cluster');
const os = require('os');

const maxProcessCount = os.cpus().length;
// 待启动多进程的 后台服务入口文件
const entryFile = path.join(__dirname, 'dist', 'index.cjs');

let reforkCount = 0;
const maxTryCount = 1000;

function startDaemon() {
  if (cluster.isWorker) {
    return;
  }

  // 在线的进程数量
  let onlineProcessCount = 0;

  // 启动主线程
  cluster.setupMaster({ exec: entryFile });

  for (let i = 0; i < maxProcessCount; i++) {
    // 创建多个子进程
    forkWorker();
  }

  function forkWorker() {
    // 保证在线进程数量小于限制的进程数量
    if (onlineProcessCount >= maxProcessCount) {
      return;
    }
    onlineProcessCount++;
    return cluster.fork();
  }

  function reforkWorker() {
    console.log('尝试重新开启新线程 ...');
    reforkCount++;
    if (reforkCount >= maxTryCount) {
      throw Error('已经超出最多尝试次数');
    }
    return forkWorker();
  }

  cluster.on('exit', (worker) => {
    console.log(`进程 pid=${worker.process.pid} 已经退出`);
    reforkWorker();
  });

  cluster.on('disconnect', (worker) => {
    console.log(`进程 pid=${worker.process.pid} 已经断开连接`);
    if (worker.isDead && worker.isDead()) {
      console.log(`进程 pid=${worker.process.pid} 已经挂掉了`);
      return;
    }
    onlineProcessCount--;
    reforkWorker();
  });
}

startDaemon();
```

在代码中，我们通过进程间的 IPC 通信，进行进程的守护管理。当个别进程出现异常中断退出的时候，就发消息给主进程，主进程就会重新开启一个新的子进程。<br/>

基于这个案例，我们可以测试一下。在开启多进程后，根据进程 id，我们强制退出进程。当子进程被强制退出后，看一看，守护进程是否会收到通信消息，自动开启新的进程。<br/>

第一张截图，我们用进程守护代码，启动了搭建平台的后台多进程服务。<br/>
![](https://static001.geekbang.org/resource/image/93/86/939a114d57938da85caf9d87733b4d86.png?wh=1808x638)

第二张截图，我们用 kill 命令，让其中一个进程退出。
![](https://static001.geekbang.org/resource/image/d1/a5/d1ed4ea6fc5993df09c94e3a9b04b6a5.png?wh=1346x388)

第三个截图，进程守护代码，监听到子进程退出信息，自动创建新的子进程补位，保持固定进程数量。
![](https://static001.geekbang.org/resource/image/b5/1d/b5536b81052d9db26d505620ac41ef1d.png?wh=1808x688)

<br/>

> 此文章为 4 月 Day6 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
