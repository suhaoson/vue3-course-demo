### 单元测试：如何打造 Vue.js 和 Node.js 全栈项目的单元测试？

#### 为什么需要对服务端做单元测试

<b>首先要明确一个观点，无论全栈项目用什么技术开发服务端，服务端单元测试都是必须要做的操作。</b>
<br/>

因为服务端不像前端那么“方便”。前端代码可以“所见即所得”，直接让代码运行在浏览器里验证前端功能效果，但是，服务端，很多功能都是“不可见”的内容，例如 HTTP 接口、HTTP 请求的状态情况、TCP 通信接口，甚至是业务代码的各种 API、数据库调用操作等等。<br/>

而且，服务端功能在开发过程中，很多功能不方便直接验证，通常需要借助一些工具来辅助验证，例如用 Postman 来做完整的 HTTP 请求服务功能验证。<br/>

#### 前端和服务端在单元测试中有什么差异

而且目前，我们只依靠前端单元测试，直接使用服务端的 HTTP 接口，间接对服务端做单元测试，是不够全面的。
<br/>
单纯的 HTTP 接口调用来渲染前端代码进行测试，覆盖不了服务端的所有功能逻辑。
<br/>
差异，主要体现在测试内容上。<br/>
前端：<br/>

- DOM 结构 DOM
- 事件使用模拟或真实的
- HTTP 请求
  <br/>

服务端：<br/>

- 数据库调用业务
- 逻辑代码
- HTTP 内容和状态

<br/>

因为全栈项目服务端的分层结构，从下往上是分别是：<b>数据层（Model）、业务层（Service）、控制层（Controller）、路由层（Router）</b>。

<br/>
服务端单元测试的三个侧重点，直接对应服务端代码分层结构的一个或者两个层级。
<br/>

![](https://static001.geekbang.org/resource/image/84/7c/8438b59f4607dcd70a381d00b139a37c.jpeg?wh=5000x2813)

- 第一点，数据库调用的测试，就是验证服务端的数据层代码。<br/>
  <b>数据库不能直接用生产环境的数据库，一般用开发测试环境的数据库进行单元测试。</b>
- 第二点，业务逻辑代码，就是验证服务端的业务层代码。<br/>
  具体操作内容就是基于测试环境的业务层的代码，调用数据层内容，进行业务功能逻辑验证，来判断业务逻辑代码的输入和输出，是否符合正确预期。
- 第三点，HTTP 内容和状态，就是验证服务端的控制层和路由层代码，从 HTTP 网络层面进行功能测试和验证。
  在这个测试过程中，真实地用测试代码发起 HTTP 请求，去访问和请求服务端提供的 HTTP 服务，最后验证 HTTP 服务响应结果是否符合正确预期。

<br/>

#### 如何选择工具进行 Node.js 服务的单元测试

在 Vue.js 前端单元测试的学习过程中，我们掌握了三个 Node.js 环境下前端单元测试工具。
<br/>

- Mocha，老牌 Node.js 环境的单元测试工具，服务端功能测试的生态比较齐全。
- Jest，React.js 官方团队维护的前端单元测试工具，基于 Node.js 环境来模拟前端浏览器环境，能测试服务端功能代码。
- Vitest，Vue.js 官方团队维护的前端单元测试工具，同样基于 Node.js 环境来模拟前端浏览器环境，也支持测试服务端功能代码。

<br/>
这里我们要讨论一个技术观点，单元测试是为了保障代码质量，尽量减少代码迭代过程不必要的问题，所以没有绝对的技术工具要求，只有质量和效率的要求。Node.js 全栈项目的单元测试没有绝对的工具限制，无论是什么前段还是后端代码，单测的核心是要验证功能模块输入和输出是否符合预期。
<br/>

#### 如何设计和实现 Node.js 服务的单元测试

按照我们前面的归纳，服务端测试场景可以分成数据库、业务代码 API 和 HTTP 请求，进行三个层面的单元测试。
<br/>
首先，数据库层面的单元测试，主要是用来验证数据操作逻辑是否符合预期。<br/>

实现具体就是引用对应的数据操作代码，在单元测试代码中进行。

```
// packages/work-server/__tests__/database.test.ts
import { describe, test, expect } from 'vitest';
import md5 from 'md5';
import {
  findUserByUsernameAndPassword,
  checkUserIsUsernameExist
} from '../src/model/user';

describe('work-server: database', () => {

  // 验证查询用户数据方法
  test('model/user.ts findUserByUsernameAndPassword', async () => {
    const result = await findUserByUsernameAndPassword({
      username: 'admin001',
      password: md5('88888888')
    });
    expect(result).toStrictEqual({
      id: 1,
      uuid: '00000000-aaaa-bbbb-cccc-ddddeeee0001',
      username: 'admin001',
      password: '1f22f6ce6e58a7326c5b5dd197973105',
      status: 1,
      info: '{}',
      extend: null,
      createTime: '2023-01-18T08:33:18.000Z',
      modifyTime: '2023-01-18T08:33:18.000Z'
    });
  });

});
```

第二个层面，业务代码的 API 单元测试，就是直接测试业务逻辑的运行结果是否符合预期。
<br/>
这个层面的单元测试，大多数跟数据层面的测试会有重叠。这是因为业务代码大部分都会涉及数据库内容的操作，所以等于间接测试了数据库层面的内容。

```
// packages/work-server/__tests__/service.test.ts
import { describe, test, expect } from 'vitest';
import md5 from 'md5';
import { queryAccount } from '../src/service/user';

describe('work-server: database', () => {
  test('service/user.ts queryAccount', async () => {
    const result = await queryAccount({
      username: 'admin001',
      password: md5('88888888')
    });
    expect(result).toStrictEqual({
      data: {
        allow: true,
        username: 'admin001',
        uuid: '00000000-aaaa-bbbb-cccc-ddddeeee0001'
      },
      success: true,
      message: '登录成功'
    });
  });
});
```

在这段测试代码中，我引用了用户登录过程中查询用户的业务代码 API，进行测试。用户登录逻辑需要先根据账号和密码查询数据库，判断用户数据是否已存在，如果存在，就可以得到允许登录的业务数据。
<br/>

最后一个层面，<b>HTTP 请求测试，主要是基于 Node.js 项目提供的 HTTP 服务，发起 HTTP 请求进行功能测试，验证路由和控制层的功能是否符合预期。</b>

#### 如何给 Node.js 服务端做基准测试

基准测试，英文是 Benchmarking 或 Benchmark，也可以简称 Bench。

> “基准测试，指通过设计科学的测试方法、测试工具和测试系统，实现对一类测试对象的某项性能指标进行定量的和可对比的测试”。

<br/>

基准测试的测试过程，是面向“某项性能指标”，而且突出“定量”和“可对比”的特性。比如在服务端中，最直接的性能指标是“单位时间能支持的请求数量”。
<br/>

简单举个例子，就是服务端提供的 HTTP 接口，能在一秒内支撑多少次请求处理。<br/>

我们用课程的登录态验证接口，基于 Vitest 做一次基准测试，来测试一秒内的请求数量情况。用 Vitest 的代码测试参考。

```
// packages/work-server/__tests__/http.bench.ts
import { bench, expect, afterAll, beforeAll } from 'vitest';
// ...
bench(
  'no login /api/get/account/online',
  async () => {
    const url = `http://${workServerHost}:${workServerPort}/api/get/account/online`;
    const res = await nodeFetch(url);
    const json = await res.json();
    expect(json).toStrictEqual({ username: null, uuid: null });
  },
  {
    time: 1000
  }
);
```

用 Vitest 执行基准测试代码后，看结果截图。<br/>

![](https://static001.geekbang.org/resource/image/97/0b/9763d583a4ced6b14cae5d925773b50b.png?wh=1920x908)

```
571.75 ops/sec ±3.27% (572 samples) fastest
```

<br/>

在基准测试结果中，描述性能指标数据，就是截图中红框标出的内容。<br/>

- “571.75 ops/sec”，其中“ops/sec”是单位， 表示每秒钟执行测试代码的次数，这个数值越大，表示这个代码每秒能执行更多次数，性能就越好。
- “±3.27%” 是测试过程中所有数据的方差，你可以通俗理解成性能数据的统计误差。
- (572  samples) ，表示取样的内容。

需要注意，目前 Vitest 的基准测试（benchmark）功能还是属于“实验”阶段，后面可能有大改动。比如，这个性能结果，我们用的是 Vitest 的 0.24.5 版本，现在最新版本有一些变化。
<br/>

如果你不想用 Vitest 进行基准测试，也可以考虑用 Node.js 的其他基准测试工具，例如 autocannon（https://www.npmjs.com/package/autocannon）。autocannon 严格上算是一种压力测试工具，基准测试在某种程度上来说也算是压力测试。就是在指定“维度”下，针对某个“性能指标”，测试能支持住多大的“压力”。

<br/>

> 此文章为 4 月 Day2 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
