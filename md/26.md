### 页面编译和运行：如何设计 Vue.js 搭建页面的渲染策略？

_根据页面功能维度的五大功能模块，“页面搭建”“页面编译和运行”“页面发布流程”“页面版本管理”和“页面渲染方式”，有了页面布局数据，接下来，我们要做的就是基于页面布局数据，进行“页面编译和运行”。_

#### 为什么要进行页面编译

在页面搭建过程中，每个物料都是独立加载对应物料组件的 JavaScript 文件，同时，也加载物料组件的 CSS 文件进行渲染。所以，每个物料组件渲染的时候，就需要两个 HTTP 请求，来请求物料 JavaScript 和 CSS 的静态资源。
<br/>
设想一下，如果页面依赖了 20 个不同的物料，按照页面搭建的方式进行渲染，就需要等 40（20x2=40）个 HTTP 请求，加载完组件资源，最后才能渲染出完整的页面。所以，按照物料组件独立加载文件的形式，来组装渲染页面，等到 HTTP 请求和响应，非常浪费时间，降低了用户体验。
<br/>
页面搭建面向用户为企业内部员工操作，加载时间久勉强可以接受，而且页面搭建功能，需要物料能够独立渲染和独立操作，所以物料就必须独立请求对应的资源。
<br/>
而前台面向外部客户，要尽可能提升页面的用户体验，减少加载时间。所以我们要合并页面依赖的物料组件资源。也就是多个 JS 和 CSS 合并为一个 JS 文件和 CSS 文件。
<br/>
这就要根据页面布局数据，整合需要用到的多个物料的 JavaScript 和 CSS 文件，各自编译成一个 Bundle 文件。
<br/>
![](https://static001.geekbang.org/resource/image/0b/c0/0b2b568e169ab76920ab150b4babaac0.jpg?wh=3000x1688)
<br/>
一句话总结页面编译的作用就是：<b>“页面编译，目的是为了减少 HTTP 请求，提升用户体验。”从技术角度上看，页面编译产出的 Bundle 文件，也提供新的一种页面组装物料的渲染方式。</b>
<br/>

#### 如何实现搭建页面的动态编译

基于 Webpack、Rollup 和 Vite 的配置规范，你可以总结出三个基本要素。
<br/>

1. 准备编译入口文件
   无论是 Webpack、Rollup 还是 Vite，要编译 JavaScript 代码，就必须提供入口文件。<br/>
   上节课我们在渲染页面搭建功能的时候，每个物料组件，会独立加载文件和渲染。这些都是物料级别的组件文件，没有页面级别的入口文件。<br/>
   所以我们需要根据布局数据拼接代码，生成页面入口文件。<br/>
   最简单的方式就是字符串的方式拼接代码。但是也存在隐患。<br/>
   还有一种方式将就是基于 ESTree 来生成 JS 代码。ESTree，你可以直接理解成 JavaScript 的抽象语法树，也就是 AST。<br/>
   例如上面代码案例中，个别代码片段，可以这么用 ESTree 描述。

   ```
   // 代码片段  const a = 1
   // 变成ESTree如下所示
   const estree1 = {
   type: 'VariableDeclaration',
   declarations: [
    {
      type: 'VariableDeclarator',
      id: {
        type: 'Identifier',
        name: 'a'
      },
      init: {
        type: 'NumericLiteral',
        value: 1
      }
    }
   ],
   kind: 'const'
   };
   ```

   有点类似于 JSON Schema；这里是用 JSON 转换 JavaScript

   ```
   // 代码片段
   /*
   function add(num1, num2) {
   return num1 + num2;
   }
   */
   // 变成ESTree如下所示
   const estree3 = {
   type: 'FunctionDeclaration',
   id: {
       type: 'Identifier',
       name: 'add'
   },
   generator: false,
   async: false,
   params: [
       {
       type: 'Identifier',
       name: 'num1'
       },
       {
       type: 'Identifier',
       name: 'num2'
       }
   ],
   body: {
       type: 'BlockStatement',
       body: [
       {
           type: 'ReturnStatement',
           argument: {
           type: 'BinaryExpression',
           left: {
               type: 'Identifier',
               name: 'num1'
           },
           operator: '+',
           right: {
               type: 'Identifier',
               name: 'num2'
           }
           }
       }
       ],
       directives: []
   }
   };
   ```

   你可以直接使用 Babel 的工具 ，就是 @babel/generator 这个 npm 模块，进行语法树的转换

2. 配置插件来编译多种语言和语法
   不同构建工具，插件配置是有差异的，之前我们学习了 Webpack、Rollup 和 Vite 这三个构建工具，其中，插件配置最方便的就是 Vite，自带了 JavaScript 的 ES6 语法的编译和 CSS 文件抽离功能，无需其它插件配置。所以，动态编译构建工具，我们就选择 Vite。
3. 分离 JavaScript 和 CSS 的代码
   因为，Vite 的默认配置，支持把代码中的 JavaScript 和 CSS 代码进行编译分离，最后拆分成两个 Bundle 文件。我们就直接使用。<br/>
   最后，就是执行编译操作了，可以直接使用 Vite 的 Node.js API，进行动态编译入口文件，大致代码就像这样。<br/>

```
    import path from 'node:path';
    import { build } from 'vite';
    import type { InlineConfig } from 'vite';

    // 动态编译入口文件的方法
    async function buildEntryFile(fullEntryFilePath: string) {
    const config: InlineConfig = {
        build: {
        emptyOutDir: false,
        outDir: path.dirname(fullEntryFilePath),
        lib: {
            name: 'MyBundle',
            entry: fullEntryFilePath,
            formats: ['iife'],
            fileName: () => {
            return 'bundle.js';
            }
        },
        rollupOptions: {
            preserveEntrySignatures: 'strict',
            external: ['vue'],
            output: {
            globals: {
                vue: 'Vue'
            },
            assetFileNames: 'bundle[extname]'
            }
        }
        }
    };
    await build(config);
    }
```

这个页面布局数据，我演示一下怎么使用。

```

{
    "layout": {
        "rows": [
            {
                "uuid": "4890074a-09f7-4b95-bd34-fecbe6e066db",
                "columns": [
                    {
                        "name": "首屏广告",
                        "uuid": "fc90dcbf-d70b-40f4-aa14-b64be2632092",
                        "width": 1000
                    }
                ]
            },
            {
                "uuid": "c248318f-ffd1-42d7-9f27-56533f7c4453",
                "columns": [
                    {
                        "name": "其它广告位1",
                        "uuid": "ac873013-d448-4ca8-b4bb-729b844ee262",
                        "width": 600
                    },
                    {
                        "uuid": "079c3fe5-f8af-475a-82ed-feb01b5730ee",
                        "width": 400
                    }
                ]
            },
            {
                "uuid": "8d0bb922-5d8c-4a67-80b0-4babaf3e2f97",
                "columns": [
                    {
                        "name": "促销商品",
                        "uuid": "e9b94120-ebe8-4418-9b13-7ea10095676d",
                        "width": 1000
                    }
                ]
            }
        ],
        "width": 1000
    },
    "moduleMap": {
        "ac873013-d448-4ca8-b4bb-729b844ee262": {
            "materialData": {},
            "materialName": "@my/material-banner-slides",
            "materialVersion": "0.9.0"
        },
        "e9b94120-ebe8-4418-9b13-7ea10095676d": {
            "materialData": {},
            "materialName": "@my/material-product-list",
            "materialVersion": "0.9.0"
        },
        "fc90dcbf-d70b-40f4-aa14-b64be2632092": {
            "materialData": {},
            "materialName": "@my/material-banner-slides",
            "materialVersion": "0.9.0"
        }
    }
}
```

最后的动态生成入口文件。

```
import Vue from "vue";
import MyMaterialBannerSlides from "../../../material/@my/material-banner-slides/0.9.0/index.esm.js";
import MyMaterialProductList from "../../../material/@my/material-product-list/0.9.0/index.esm.js";
const {
  h,
  createApp,
  defineComponent
} = Vue;
const materialDeps = {
  "@my/material-banner-slides": MyMaterialBannerSlides,
  "@my/material-product-list": MyMaterialProductList
};
const pageLayoutData = {
  "layout": {
    "rows": [{
      "uuid": "4890074a-09f7-4b95-bd34-fecbe6e066db",
      "columns": [{
        "name": "首屏广告",
        "uuid": "fc90dcbf-d70b-40f4-aa14-b64be2632092",
        "width": 1000
      }]
    }, {
      "uuid": "c248318f-ffd1-42d7-9f27-56533f7c4453",
      "columns": [{
        "name": "其它广告位1",
        "uuid": "ac873013-d448-4ca8-b4bb-729b844ee262",
        "width": 600
      }, {
        "uuid": "079c3fe5-f8af-475a-82ed-feb01b5730ee",
        "width": 400
      }]
    }, {
      "uuid": "8d0bb922-5d8c-4a67-80b0-4babaf3e2f97",
      "columns": [{
        "name": "促销商品",
        "uuid": "e9b94120-ebe8-4418-9b13-7ea10095676d",
        "width": 1000
      }]
    }],
    "width": 1000
  },
  "moduleMap": {
    "ac873013-d448-4ca8-b4bb-729b844ee262": {
      "materialData": {},
      "materialName": "@my/material-banner-slides",
      "materialVersion": "0.9.0"
    },
    "e9b94120-ebe8-4418-9b13-7ea10095676d": {
      "materialData": {},
      "materialName": "@my/material-product-list",
      "materialVersion": "0.9.0"
    },
    "fc90dcbf-d70b-40f4-aa14-b64be2632092": {
      "materialData": {},
      "materialName": "@my/material-banner-slides",
      "materialVersion": "0.9.0"
    }
  }
};
const moduleComponentMap = {};
Object.keys(pageLayoutData.moduleMap).forEach(uuid => {
  const materialName = pageLayoutData.moduleMap[uuid].materialName;
  moduleComponentMap[uuid] = materialDeps[materialName];
});
const App = defineComponent({
  setup() {
    const Rows = pageLayoutData.layout.rows.map((row, rowIndex) => {
      const Columns = row.columns.map((col, colIndex) => {
        const Material = moduleComponentMap[col.uuid];
        const props = pageLayoutData.moduleMap[col.uuid]?.materialData || {};
        const Mod = h(Material || 'div', props);
        return h('div', {
          style: {
            width: col.width,
            display: 'flex'
          },
          'data-col': colIndex
        }, Mod);
      });
      return h('div', {
        style: {
          width: row.width,
          margin: '10px 0',
          display: 'flex',
          flexDirection: 'row'
        },
        'data-row': rowIndex
      }, Columns);
    });
    return () => {
      return h('div', {
        style: {
          width: pageLayoutData.layout.width,
          margin: '0 auto'
        }
      }, Rows);
    };
  }
});
const app = createApp(App);
app.mount('#app');
```

<br/>
页面编译的技术实现流程，就是这样的三步，我们简单总结一下。
<br/>

![](https://static001.geekbang.org/resource/image/86/1c/86b2d723c818cb1c8d26bc681fcef51c.jpg?wh=3000x1688)

- 首先基于页面布局数据，用 ESTree 拼接和生产入口文件。
- 然后，用构建工具，例如 Vite，基于入口文件，把所有的物料文件进行打包编译。
- 最后，整个页面的静态资源通过编译，生成一个 JavaScript 的 Bundle 文件，和一个 CSS 的 Bundle 文件。

<br/>
在完整的代码案例里，你可以通过创建页面，提交发布页面，来动态编译页面的 Bundle 文件。最终可以在页面列表中，点击去访问 Bundle 文件渲染的预览页面。

![](https://static001.geekbang.org/resource/image/dd/3e/ddcf49e4518fd36yyed389d0076fdf3e.png?wh=1920x1043)

#### 如何设计渲染策略

运营搭建平台，最终生产的页面是提供给外部客户使用的，页面的稳定性和安全性就很重要。
<br/>
页面渲染策略，就是要在“用户体验”和“页面稳定性”做一定的权衡处理。怎么设计渲染策略呢？
<br/>
既然是要做权衡，那就有优先级的选择，我们可以根据渲染方式的优先级，设计渲染策略。<br/>

第一步，优先使用编译后的 Bundle 文件渲染页面，提升用户的体验。<br/>
第二步，监听页面报错，如果 JavaScript 的 Bundle 文件报错，导致页面白屏，就进入多模块独立文件渲染模式。<br/>
第三步，判断浏览器兼容性，选择合适的多模块的物料独立渲染方式。<br/>

如果浏览器支持 ESM，就基于 ESM 模块格式，每个模块单独加载文件独立渲染，尽量隔离掉错误的干扰。如果浏览器不支持 ESM，就用 AMD 模块格式，加载 RequireJS 的 AMD 运行环境，再让每个模块单独加载文件独立渲染，尽量隔离掉异常物料组件的报错干扰。
<br/>
这里的物料独立渲染，就是把每个物料当做一个 Vue.js 应用来渲染，基于 createApp 这个 API 来独立渲染每个物料。替换掉 Bundle 文件聚合所有物料组件，渲染一个应用的模式
<br/>
具体渲染策略实现流程：
![](https://static001.geekbang.org/resource/image/fc/b5/fc926371fb2a0ebec458b6b9104d17b5.jpg?wh=3000x1688)

<br/>
渲染策略的要点，最核心的就是独立物料模块渲染，其实就是把物料组件当做独立的应用来渲染。Bundle 文件渲染方式是只渲染一个 Vue.js 应用，当应用里出现报错，导致整体页面奔溃，就多变成模块独立加载渲染。这个时候，每个物料是独立的 Vue.js 应用进行独立渲染。隔离出错误模块或错误代码。
<br/>
所以页面渲染策略的思路可以用一句话总结：“尽量保证页面功能全部渲染，如果出现异常，就降级成部分模块渲染，保证大部分功能可用性”。
<br>

> 此文章为 3 月 Day27 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
