### Koa.js：如何结合 Koa.js 开发 Node.js Web 服务？

#### 为什么要用 Node.js 开发 Web 服务？

我们课程中运营搭建的全栈项目选择 Node.js 开发，有三个优势：<br/>

1. 前后端统一用 JavaScript，学习成本低；
2. 代码可前后端复用，能提高开发效率；
3. Vue.js 组件可以用于前端和服务端渲染。

<br/>
市面上主流用来开发 Web 服务的框架有 Express.js、Koa.js、Egg.js、Nest.js 等<br/>
用 Node.js 开发 Web 服务已经确定了，但 Node.js 只是个 JavaScript 运行环境，那该选择什么框架或者工具来开发 Web 服务呢？---Koa.js
<br/>

我们课程项目里选择 Koa.js，有这几个原因：<br/>

- Koa.js 框架精简，轻量简单，源码就几个 JavaScript 文件；
- Koa.js 洋葱中间件模型的灵活优势；
- Koa.js 的中间件生态丰富；
- 国内大厂广泛使用 Koa.js，用于封装业务 Web 框架，例如阿里开源的 Egg.js 等。

<br/>

#### 如何使用 Koa.js 开发 Node.js 服务?

所有 Web 服务框架都是处理 HTTP 请求和响应的，不管是 Koa.js，还是 Express.js、Egg.js 等 Node.js Web 框架，最核心功能就是处理 HTTP 请求和响应，<b>框架之间的差异，主要是处理 HTTP 的流程操作或设计理念不一样。</b>

我们先看相同，再看差异。

- ##### 核心要素 http 模块

演示一下在 Node.js 中最简单的一个 HTTP 服务，如下代码所示：

```
// easy-server.cjs
const http = require('node:http');

const server = http.createServer((req, res) => {
  const url = req.url;
  const html = `
  <html>
    <head>
      <meta charset="utf-8" />
    </head>
    <body>
      <h1>当前页面链接: ${url}</h1>
    </body>
  </html>
  `;
  res.end(html);
});

server.listen(6001, () => {
  console.log('服务已经启动，浏览器打开 http://127.0.0.1:6001/');
});
```

这段代码是通过 Node.js 的“http”模块，快速实现一个 HTTP 服务，所有的 Node.js Web 框架的最核心点就是利用这个 Node.js 原生能力。
效果如下：
![](https://static001.geekbang.org/resource/image/49/c7/49c9917c41870de0e20d263a925bc2c7.png?wh=606x411)

上述的代码也可以直接用 TypeScript 来编写，代码可以改成这样：

```
// easy-server.ts
import http from 'node:http';

const server = http.createServer(
  (
    req: http.IncomingMessage,
    res: http.ServerResponse<http.IncomingMessage>
  ) => {
    const url = req.url;
    const html = `
  <html>
    <head>
      <meta charset="utf-8" />
    </head>
    <body>
      <h1>当前页面链接: ${url}</h1>
    </body>
  </html>
  `;
    res.end(html);
  }
);

server.listen(6001, () => {
  console.log('服务已经启动，浏览器打开 http://127.0.0.1:6001/');
});
```

这个时候，我们可以使用 vite-node 这个 npm 模块，在本地计算机全局安装这个命令，直接启动 TypeScript 文件，如执行这个命令 “vite-node ./easy-server.ts”。

<br/>

- ##### 不同设计理念:
  我们主要用到 Web 框架是 Koa.js，那么它核心的分析服务设计理念，就是处理 HTTP 请求的中间件流程设计，也就是“洋葱模型”。
  <br/>
  示例代码：

```

/* eslint-disable no-console */
import Koa from 'koa';
import type { Context, Next } from 'koa';

const app = new Koa();

app.use(async (ctx: Context, next: Next) => {
  console.log(`[${ctx.path}] 打印 001`);
  await next();
  console.log(`[${ctx.path}] 打印 004`);
});

app.use(async (ctx: Context, next: Next) => {
  console.log(`[${ctx.path}] 处理HTTP响应之前`);
  ctx.body = `<html>
  <head>
    <meta charset="utf-8" />
  </head>
  <body>
    <h1>当前页面链接: ${ctx.path}</h1>
  </body>
</html>`;
  await next();
  console.log(`[${ctx.path}] 处理HTTP响应之后`);
});

app.use(async (ctx: Context, next: Next) => {
  console.log(`[${ctx.path}] 打印 002`);
  await next();
  console.log(`[${ctx.path}] 打印 003`);
});

app.listen(6001, () => {
  console.log('Koa.js 服务已经启动，浏览器打开 http://127.0.0.1:6001/');
});
```

可以访问 http://127.0.0.1:6001/hello 连接，得到控制台这样的打印顺序：
<br/>
![](https://static001.geekbang.org/resource/image/b3/d8/b3082666c44213b87c138c0da33f18d8.png?wh=783x469)

这种打印结果就是洋葱模型的效果，每个异步函数，都是一个中间件，执行时候“先进后出”。其实，每个中间件，都等于一个 Promise。拆解为 Promise 写法，如下：

```
// middleware-demo.ts
const context = {};

async function middleware1(ctx: any, next: any) {
  console.log('打印 001');
  await next();
  console.log('打印 004');
}

async function middleware2(ctx: any, next: any) {
  console.log('处理HTTP响应之前');
  await next();
  console.log('处理HTTP响应之后');
}

async function middleware3(ctx: any, next: any) {
  console.log('打印 002');
  await next();
  console.log('打印 003');
}

Promise.resolve(
  middleware1(context, async () => {
    return Promise.resolve(
      middleware2(context, async () => {
        return Promise.resolve(
          middleware3(context, async () => {
            return Promise.resolve();
          })
        );
      })
    );
  })
).then(() => {
  console.log('执行结束');
});

```

执行后的打印效果如下：
![](https://static001.geekbang.org/resource/image/66/33/66562247cf579d56ba84b88ab2678033.png?wh=761x294)

简单理解，所谓的洋葱模型中间件，就是 Promise 嵌套。“先进后出”的效果就是 Promise 嵌套中 resolve 前后控制。
<br/>
![](https://static001.geekbang.org/resource/image/9d/bd/9d70yyf2ca465862aea95ef1af818ebd.jpg?wh=1920x1197)

我们课程里涉及到的 Node.js Web 服务，都是基于 Koa.js 来选择需要功能中间件，组装成需要的功能服务。<br/>
一般 Web 服务基础功能有四点：<br/>

- 服务端路由控制；
- 静态资源加载；
- HTML 页面渲染；
- 提供 API 接口（Ajax/JSONP 接口）。

<br/>
Koa.js 可以通过找对应的中间件，来实现对应功能：

- 中间件 koa-router 处理路由；
- 中间件 koa-static 处理静态资源，同时，用 koa-mount 来辅助处理静态资源的 URL 前缀；
- Koa.js 自带的 Context 控制渲染 HTML 和处理 API。

我们课程 Web 服务架构的具体目录，可以设计成这样：

```
# packages/work-server/src
.
├── controller/*
├── public/*
├── service/*
├── template/*
├── util/*
├── router.ts
└── index.ts
```

我们来分析一下主要的目录和文件设计：

- 文件 router.ts，是路由层 ，定义 Web 服务的 URL 内容；
- 目录 controller，是控制层，控制页面内容和 API 内容的 HTTP 响应；
- 目录 service，是业务层，提供一些业务逻辑的操作；
- 目录 public，是静态资源目录，存放 JavaScript、CSS 和图片等静态资源。

![](https://static001.geekbang.org/resource/image/86/80/86c15768d31b41eaf344763977628580.jpg?wh=1920x1080)
<br/>
具体的技术结构可以结合下图理解：<br/>
![](https://static001.geekbang.org/resource/image/5f/fd/5f2dece9f2b4c96a36c4071f9bc69efd.jpg?wh=1920x1080)
<br/>

#### 为什么需要前后端项目分离？

考虑三个视角，分别是技术视角、管理视角和行情视角。
<br/>

- 从技术视角上看，前后端分离能让前端代码和服务端代码解耦，不会杂糅混合在一起，代码的目录和职责都很分明。反之，如果前后端代码耦合在一起，类似 PHP、JSP 等技术，一些前后端的功能代码都写在一起，虽然开发方便，但是不好区分功能职责。
- 从管理视角上看，项目的开发不是一次性的，会随着业务需求的变化不停迭代。如果我们不做前后端代码的解耦，耦合的代码在后续的频繁修改下，容易埋下代码混乱的隐患，直到陷入难以修改维护的困境。还有一个关注的因素：“迁移成本”。
- 第三个就是行情视角，目前国内大部分企业的 Web 项目基本都是前后端分离，只有极少数陈年老项目是前后端代码耦合在一起的。但国外的项目很多还是前后端耦合在一起的项目，例如很多国外网站是基于 PHP 开发的项目，或者基于 PHP 框架 WordPress，前端代码很多是写在 PHP 文件里的。

#### 如何设计 Vue.js 和 Koa.js 前后端分离项目？

首先我们做一下整体的前后端的关系设计，看流程图：
<br/>
![](https://static001.geekbang.org/resource/image/fd/2b/fd90911a9e8be0e4ca1aea517a221c2b.jpg?wh=1920x1080)
这里，前端项目和后端项目是两个独立子项目，前端跟后端项目的联动主要是提供静态资源。前端项目将 JavaScript 和 CSS 等静态资源给后端，让后端能在渲染 HTML 页面时加载前端的静态资源，进而渲染页面。
<br/>

项目实现拆成 monorepo 里的两个子项目：

- 前端子项目，主要是管理浏览器运行的 JS/CSS 代码；
- 后端子项目，主要是管理 Node.js 环境运行的代码。

- #### 开发模式
  ![](https://static001.geekbang.org/resource/image/97/d6/97c52b5543da5d5bd20f4f5d743967d6.jpg?wh=1920x1080)
  这里可以看出，前端子项目的开发模式是用 Vite 启动开发服务来编译 Vue.js 代码的，而且提供了一个 8002 端口的服务。开发过程中，我们基本都用 TypeScript 语法开发，基于 Vite 的开发服务来实现 ES Modules 模块的编译和热更新。
  <br/>
  后端子项目用 Koa.js 直接搭建服务，也是用 TypeScript 语法开发，并基于 nodemon 和 ts-node 实现开发过程中的热更新。nodemon 模块主要用于 Node.js 服务代码的热更新，ts-node 模块主要是编译 TypeScript 代码。
  <br/>
  当 Koa.js 通过 nodemon 和 ts-node 启动开发模式的 Web 服务后，就可以提供渲染 HTML 和数据 API 的 HTTP 请求，并提供给前端的 Vite 服务。
- #### 生产模式
  ![](https://static001.geekbang.org/resource/image/27/91/272721374ab1yy22ebeec9c6f0933891.jpg?wh=1920x1080)
  从图中可知，前端通过 Webpack 编译，将前端子项目的 TypeScript 和 Less 代码，分别编译成 JS 和 CSS 文件。这里用 Webpack，我们主要考虑的是生产环境用 Webpack 这个老牌框架，会更稳定些，构建出来的结果比较放心。
  <br/>
  后端子项目基于 Rollup 编译成 CommonJS 模块，主要是用 Rollup 将 TypeScript 代码文件一一对应编译成 JavaScript 代码，可以直接在 Node.js 环境运行。同时将前端子项目编译结果一同打包出交付产物。具体交付构建流程，如下图所示：
  ![](https://static001.geekbang.org/resource/image/1d/a4/1d0e7a13651cfbeaff194045fdc1d7a4.jpg?wh=1920x1080)

开发模式下前后端所有代码还是处于 TypeScript 的“中间状态”。<br/>
生产模式要把源代码的“中间状态”转成“最终状态”，直接变成最终的运行代码的状态。
<br/>
这个“变化的过程”就是将前端 TypeScript 和 Less 代码编译成 JavaScript 和 CSS 代码，能在浏览器里直接运行；将后端 TypeScript 代码编译成 CommonJS 格式 JavaScript 代码，能在 Node.js 环境里直接运行。

> 此文章为 3 月 Day18 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
