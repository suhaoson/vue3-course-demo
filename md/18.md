### Node.js 服务端渲染页面：客户端渲染和服务端渲染有何区别？

在 JavaScript 代码还没通过 &lt;script&gt; 标签加载出来之前，整个页面一直是“白屏”，这个状态要等待 JavaScript 加载完，才能渲染出页面的功能视图。就像图中这样，浏览器控制台记录的白屏过程：
![](https://static001.geekbang.org/resource/image/78/a3/7869521f8b5a584c0c6b1707dbe377a3.png?wh=981x716)

为什么会有这个现象呢？
<br/>

其实也很简单，因为图中渲染方式是“浏览器端渲染”，先等待页面的 HTTP 请求响应，返回页面的 HTML，此时 HTML 还没有视图内容，只有 JavaScript 和 CSS 这些静态资源的引用，等到这些 HTML 里依赖的前端资源加载完毕后，最后执行 JavaScript 代码渲染出 HTML 结果，同时，对应 CSS 资源才会渲染样式效果。
<br/>
页面资源越大，需要加载的时间就越久。导致白屏的等待太久，用户的体验就很糟糕。
<br/>
解决方法就是采用服务端渲染
<br/>

#### 什么是浏览器渲染和服务端渲染？

- 客户端渲染，英文术语是 Client Side Render，简称 CSR（后面我们就统一用 CSR 这个术语来表示）。<br/>
  <b>“客户端渲染”就是通过浏览器中运行的 JavaScript 代码来生成 HTML 内容，从而渲染页面视图。</b>

- 服务端渲染，英文术语是 Server Side Render，简称 SSR（后面我们统一用 SSR 这个术语来表示）。<br/>
  <b>SSR 是由服务端处理好页面的 HTML 内容，再通过 HTTP 请求响应给浏览器渲染。</b>
  <br>
  具体技术过程是这样子的：浏览器输入 URL 发起了页面的 HTTP 请求，服务端接收请求后，再响应页面的 HTML 给浏览器，浏览器拿到页面 HTTP 请求返回的 HTML 数据，就可以开始渲染拿到的 HTML 的渲染视图了，如果 HTML 里有 CSS 内容，也会一并渲染出对应的样式。

![](https://static001.geekbang.org/resource/image/fd/6a/fd47e76731df54534f7a7a227c323f6a.jpg?wh=1920x1080)

<b>所以，CSR 和 SSR 的最大区别就是“初始化页面视图时候”的“HTML 生成方式”，一个是在浏览器里拼接 HTML，一个是在服务器里拼接 HTML，这里的 HTML 也包括 &lt;style&gt; 标签里的 CSS 内容。</b>
<br/>
那么 SSR 的优势是什么呢？
<br/>
SSR，是浏览器在请求页面 URL 的时候，直接返回视图的 HTML 内容，这意味着在其它环境里，例如另一个服务器环境里发起这个 URL 的 HTTP 请求，也能拿到这个 HTML 内容，所以<b>服务端渲染还能支持搜索引擎抓取页面数据，也就是支持“SEO”。</b>
<br/>
我们小结一下两种渲染方式的作用：<br/>

- CSR：在浏览器里动态渲染 HTML、在浏览器里实现交互效果；
- SSR：支持页面加载的首屏体验优化、支持网页的 SEO（搜索引擎优化）。

#### 如何实现 Vue.js 服务端渲染？

我们先分析一下 Vue.js 能在浏览器端实现渲染的原理，从中找出参考思路：<br/>
CSR 的原理就是，把 Vue.js 的模板语法代码或 JSX 语法代码，编译成纯 JavaScript 代码，然后通过 Vue.js 的 runtime，也就是 Vue.js 的运行时，执行编译后的 Vue.js 代码，并渲染出对应的 DOM（也就是 HTML）和绑定 DOM 的事件。
<br/>
服务端渲染呢？<br/>
先看第一个关键点，能执行 JavaScript 代码的服务端环境，必须首选 Node.js 环境。Vue.js 官方也提供了 Node.js 的渲染方法，<b>支持在 Node.js 环境里执行“非编译模式”的 Vue.js 代码，或者是编译后的 Vue.js 代码，将其转化成 HTML 结果</b>。<br/>
第二个关键点，Vue.js 是如何在 Node.js 的服务端渲染出 HTML 内容呢？其中两个关键点：<br/>

1. 第一步，把 Vue.js“非编译模式代码”或者“编译结果代码”转化成 HTML 字符串或数据流；
2. 第二步，把 HTML 内容写入 HTTP 响应返回给浏览器。
   <br/>

通过 Vue.js 官方的两个 API 来处理转化 HTML：

- 第一个 API 是 createSSRApp，创建一个服务端渲染的应用，类似 CSR 里的 createApp 这个 API，可以有效提取只能在服务端渲染的内容。
- 第二个 API 是 renderToString，把 SSR 的应用转成 HTML 字符串。

<br/>
我们也可以使用另一个 API renderToStream 来代替 renderToString，最终转化的结果是 HTML 数据流，是二进制的数据（后面为了方便显示生成 HTML 的字符串内容，演示代码我们都使用 renderToString 开发）。
接下来第二步，
要特别注意的是，<b>在实现 SSR 的过程中，需要做好浏览器和 Node.js 各自独有的 JavaScript API 的判断隔离。如果 Vue.js 组件或者应用代码里有浏览器的 JavaScript API，在 Node.js 环境运行是会报错的</b>。
<br/>
SSR 还有一点需要注意，也可以说是缺点吧，SSR 渲染出来的视图，只是静态的 HTML 内容。Vue.js 组件里如果有交互事件，在 SSR 的渲染结果中是不会生效的。如果需要实现交互效果，就需要浏览器里执行相关的 JavaScript 代码，也就是需要 CSR 进行处理。
<br/>
这个时候就需要 CSR 和 SSR 渲染的结合<br/>

#### 如何设计全栈项目的 Vue.js 的 SSR 和 CSR？

一提到 SSR 和 CSR 的结合渲染，你或多或少会想到一个技术术语——<b>“同构渲染”</b>。
<br/>
Vite 官方提供了一个 SSR 和 CSR 结合渲染的案例：https://github.com/vitejs/vite/tree/main/playground/ssr-vue，你可以参考学习，这个案例上手很简单轻便，但是前后端共用的 Vue.js 代码是耦合在一起的，不适合我们课程中设计的前后端分离项目。
<br/>
既要支持前后端解耦分离的项目，又要支持一套 Vue.js 代码能兼容 SSR 和 CSR 两种渲染方式，该怎么办呢？<br/>
我们可以将同一套前端的 Vue.js 代码，做些兼容处理工作，编译出两套渲染代码，分别支持浏览器环境和 Node.js 环境的渲染，具体设计思路是这样子的：
![](https://static001.geekbang.org/resource/image/45/fb/45f1a279ff3bbd92be91f6df78d1dafb.jpg?wh=1920x1080)

想实现图中的内容，需要四步：
<br/>

1. 前端子项目 Vue.js 组件，编译成面向浏览器可运行的 JavaScript 代码；
2. 前端子项目 Vue.js 组件，编译成面向 Node.js 服务可以运行的 JavaScript 代码；
3. 后端子项目引用对应编译后的 JavaScript 代码，运行相关的结果；
4. 页面渲染时候，按照需要进行 SSR 或者 CSR。
   <br/>
   第一步，前端子项目的 Vue.js 组件组装成功能页面代码，其中也包括所有交互功能的代码。这跟我们之前学过的编译操作、开发模式和生产模式一样，没什么太大区别。<br/>
   <br/>
   第二步，根据需要，把 Vue.js 组件按需组装 SSR 所需要渲染的内容，这时候可以按照需要，选择页面的 Vue.js 组件，尽量只选择首屏需要的组件或者 SEO 需要用到的组件。记得同时做好 Node.js 环境的 JavaScript API 兼容。避免出现兼容问题，还是建议编译为 CommonJS 模块格式。
   ![](https://static001.geekbang.org/resource/image/0e/21/0ed73dfe29365a3d17bb10d5d1b0be21.jpg?wh=1920x1080)
   <br/>
   第三步，在 Node.js 服务项目中，通过服务端路由解析出不同页面的 ID 或者页面名称，查找是否存在 SSR 的 CommonJS 模块代码：
   <br/>

   - 如果存在，就获取 CommonJS 模块和对应的 CSS 代码，通过 Vue.js 的 SSR API 进行转换成 HTML，最后响应给浏览器，完成一个 SSR 流程和后续在浏览器里的 CSR 流程。
   - 如果页面的 SSR CommonJS 代码不存在，就响应默认的 HTML，走普通的 CSR 流程。

   ![](https://static001.geekbang.org/resource/image/be/45/be4917fffe9d1a25db03eb2f085de145.jpg?wh=1920x1080)
   <br/>
   第四步，观察和等待浏览器的执行。我拿这节课的源码案例来演示一下最终效果，用 SSR+CSR 渲染了运营平台的首页：

<br/>

#### 如何合适地选择使用 SSR？

从分析和案例效果都可以看出，SSR 能减少白屏的时间，甚至白屏的时间可以忽略不计。<br/>
是否所有项目都适合 SSR，或是是项目必备的能力吗？<br/>
不是的。主要原因是有些场景是不希望支持 SEO 的。比如有些页面是不想被浏览器引擎“抓取”页面数据的（数据安全）；高并发大流量的服务场景。因为 SSR 在处理 HTML 过程中需要拼接字符串等操作行为，这个过程要消费内存和 CPU 的资源。<br/>

涉及数据敏感、服务器压力的场景就不合适用 SSR。当然这只是直观的选择方式，如果企业内有专业的数据安全团队和服务运维团队辅助，他们可以支持数据“防爬”和服务动态扩容，那么这两类问题场景也不是问题，可以愉快使用 SSR。
<br/>

> 此文章为 3 月 Day19 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
