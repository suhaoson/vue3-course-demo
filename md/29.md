### 前台页面的渲染方式：如何设计前台页面的渲染策略？

进一步学习前台页面的渲染。这也是运营搭建平台中，页面功能维度的最后一个环节——“页面渲染方式”。<br/>
将我们之前学的一些分散的技术点集成起来。比如 Vue.js 的服务端渲染、Vue.js 组件的多种模块格式等等，这些技术散点都是你的知识储备。通过实际项目应用实践，有机结合起来，应用到搭建平台的前台场景中

#### 1. 设计前台页面的链接

页面渲染的第一件事，就是在要在浏览器输入页面的 URL，也就是页面的链接，所以我们今天第一件事就是设计页面的链接。

一般这么设计：

```
/*
 https://${域名}/p/${页面uuid}
 例如：
*/
https://xxx.xx/p/10001000-aaaa-bbbb-cccc-ddddeeee0000
```

你可能会觉得页面 uuid 太长了，导致 URL 太长，影响页面链接传播效果。我们可以换种 uuid 生成方式，在后台服务创建页面生成 uuid 时候，换一种简单的随机字符串生成方法。
<br/>
可以采用随机生成只有英文和数字的短字符串
<br/>

```
// 随机生成字符串，包括0-9a-z的短字符串内容
Math.random().toString(36).substring(2)
```

<b>要特别注意，URL 里不能用页面在数据库的自增数字 id。</b>避免“爬虫”抓取页面数据，造成页面泄漏。

#### 2. 设计前台页面的浏览器端渲染

我们之前学过 Vue.js 页面的浏览器端渲染（客户端渲染）和服务端渲染原理，CSR 和 SSR。页面大部分功能，都是基于浏览器端渲染来实现的，服务端渲染的作用更多是减少白屏时间和支持 SEO。
<br/>

首先，回顾一下“物料组件多种模块格式”和“页面编译和运行”这两节课，我们可以总结出三种浏览器端渲染方式。

- Bundle 文件渲染<br/>
  ![](https://static001.geekbang.org/resource/image/d4/6b/d464f7a0e13efe57008207b5dab81a6b.jpg?wh=4000x2678)
  从图中可以看出 Bundle 文件渲染分为四步：<br/>
  - 第一步：浏览器发起前台服务请求。
  - 第二步：服务器接受请求，解析出页面 uuid。
  - 第三步：数据库查找页面数据，判断页面是否存在，如果存在就拼接对应的 HTML 结果。
  - 第四步：浏览器执行和渲染服务端响应回来的 HTML 结果。
- 基于 ESM 模块的动态加载渲染<br/>
  ![](https://static001.geekbang.org/resource/image/60/76/605617c9722dd89cf6eede85778d6576.jpg?wh=4000x2678)
  基于 ESM 模块的动态加载渲染分成五个步骤。
  - 第一步：浏览器发起前台服务请求。
  - 第二步：服务器接受请求，解析出页面 uuid。
  - 第三步：数据库查找页面数据，判断页面是否存在，如果存在就把页面数据埋在 HTML 全局变量中。
  - 第四步：浏览器执行和渲染服务端响应回来的 HTML 结果。
  * 第五步：运行 ESM 运行时来异步加载 ESM 模块，动态加载物料渲染页面。
- 基于 AMD 模块的动态加载渲染<br/>
  - AMD 动态渲染方式，具体步骤和 ESM 基本一样，只是在最后一步中，动态加载物料组件资源的方式，从纯 ESM 动态加载渲染，变成基于 RequireJS，加载 AMD 物料组件模块，进行动态渲染。

<br/>

#### 3. 做前台渲染测试的落地实现

根据之前课程页面渲染策略的理论技术方案，进入降级渲染逻辑的部分，我稍作调整，画了一张步骤图。
<br/>
![](https://static001.geekbang.org/resource/image/a2/c0/a2bbeb3075c99f32e797be6d758e4dc0.jpg?wh=4000x2678)

渲染策略分成三个步骤。<br/>

- 第一步：默认 Bundle 文件渲染，监听页面错误异常。
  第一步，默认 Bundle 文件渲染，监听页面错误异常。<b>核心操作是要监听页面错误，我们可以分成“Vue.js 应用内部错误”和“其它错误”。</b>
  <br/>
  在 Vue.js 应用的内部，可以通过 Vue.js 官方提供的 API（app.config.errorHandler）来捕获错误异常。

  ```
  app.config.errorHandler = (err, instance, info) => {
  console.log('捕获到Vue.js内部报错: ', err);
  // 处理后续的页面降级处理
  }
  ```

  其它错误，可以通过监听 window 的错误事件。

  ```
  window.addEventListener('error', (err) => {
  console.log('捕获到其它报错: ', err);
  // 处理后续的页面降级处理
  });
  ```

- 第二步：渲染提示用户，选择是否降级渲染。
  ![](https://static001.geekbang.org/resource/image/8d/c4/8da6e34d5ace7747b20bd60d04cdd2c4.png?wh=1920x890)
  <br/>
  为什么要让客户自行选择降级呢？为什么不能直接用代码处理强制降级呢？<br/>
  客户遇到页面出现错误的时候，程序员不一定能第一时间得到反馈和处理问题。与此同时，客户遇到页面错误后，不一定影响页面主要功能的使用，这时候强制降级可能会适得其反。
- 第三步：根据浏览器环境，选择 ESM 或 AMD 渲染方式。
  如何判断页面是否支持 ESM 呢？这里我们可以基于 impormap，来用执行 import 操作，检测是否支持 ESM 模块。<br/>

  ```
  // packages/portal-server/src/public/static/page-helper.js
  let canSupportESM = true;
  try {
  // 用 import()动态加载 importmap 指向的 vue 模块
  import('vue').then(() => {
  canSupportESM = true;
  }).catch((err) => {
  console.warn(err);
  // 如果出错，就证明当前不支持 ESM
  canSupportESM = false;
  });
  } catch (err) {
  console.warn(err);
  // 如果出错，就证明当前不支持 ESM
  canSupportESM = false;
  }
  ```

 <br/>

课程案例是直接在第二步时候就判断降级选择方案，然后生成对应的 URL，提供给用户触发降级渲染页面时，跳转到降级页面使用。
<br/>
进行页面降级跳转的时候，进入 ESM 或 AMD 降级渲染的页面链接，这个链接其实跟原来的 Bundle 渲染页面是同一个 URL 路径 Path，只不过携带的参数不同。后端根据参数做对应的服务端处理。

  <br/>

你可以看对应截图。同一个页面 URL 的 Bundle 渲染结果。
![](https://static001.geekbang.org/resource/image/66/5c/66e62a843660583461af27295769d35c.png?wh=1920x1109)
<br/>
基于同一个页面 URL 路径，带上参数“runModule=amd”的渲染结果。
![](https://static001.geekbang.org/resource/image/37/47/3730c47c03581df0cb1ab1c44f683e47.png?wh=1920x1109)
<br/>
基于同一个页面 URL 路径，带上参数“runModule=esm”的渲染结果。
![](https://static001.geekbang.org/resource/image/48/8f/48eccc3bdf7e1c6a2b0d672de1b4008f.png?wh=1920x1202)

<br/>

#### 4. 设计和实现前台页面的服务端渲染

服务端渲染主要是解决白屏等待问题和 SEO 需求，其中，最重要的是 SEO 需求。所以做服务端渲染之前，我们要考虑是否有 SEO 需求，如果有需求，就要必须要用服务端渲染。
<br/>
关键步骤如图：
![](https://static001.geekbang.org/resource/image/e7/e3/e7c2a8cdca2f3349520433b040be6ae3.jpg?wh=4000x2678)
可以分为四个步骤：

- 第一步，浏览器发起前台服务请求。
- 第二步，服务器接受请求，解析出页面 uuid。
- 第三步，数据库查找页面数据，根据页面布局数据，获取物料组件的 CommonJS 模块，将其动态编译组装成页面 HTML 字符串。
- 第四步，浏览器执行和渲染服务端响应回来的 HTML 结果。

#### 服务端渲染存在哪些隐患

我们用的是 Node.js 来开发项目的服务端功能。那么基于 Node.js 在服务端，做运营搭建平台的服务端渲染，会有哪些隐患呢？<br/>

- 首先，页面是由物料组件组成的，而且物料组件不是固定的，是动态的。所以每次做服务端渲染，都需要<b>在 Node.js 环境里做动态的组件编译，生成 HTML 结果</b>。

- 其次，一个页面可以存在多个物料，可能几个，可能几十个。那么 <b>Node.js 服务在组装页面 HTML 代码的时候，就要对每个物料 Vue.js 组件，传入组件的数据源，编译成 HTML 代码。</b>这个编译过程是外部客户访问页面时候进行的，也需要时间执行操作。页面使用物料一旦变多，服务端动态编译 HTML 时间就变长。

<br/>
所以，这也是我们刚刚说的“服务端渲染可以解决白屏等待时间，但是不一定能完全解决”，反而可能因为编译物料组件过多，白屏时间更长。
<br/>
总的来说，Node.js 做 Vue.js 的全栈服务，可能存在的隐患大致可以分成三点。<br/>

- 编译复杂组件耗性能。Node.js 服务，处理复杂物料组件，比较耗性能。
- 组装编译页面耗性能。如果页面布局复杂，物料组件依赖太多，Node.js 处理页面的时候，会占用较多的 CPU 和内存性能。
- 服务端运行 Vue.js 不可预测的错误。物料组件的 CommonJS 模块格式，不一定能百分百在 Node.js 服务端处理成 HTML，可能组件里存在浏览器 API 的使用，导致在服务器运行时候中报错。

<br/>
不过，解决办法也是有的，这三点隐患其实都<b>指向一个问题，客户访问页面的时候，要动态“编译组件成 HTML”和“组装页面成 HTML”</b>，所以，我们可以前置这个步骤，放在后台服务中，在页面发布流程中，就把页面的服务端 HTML 直接编译出来，放到 CDN 给前台服务使用。
<br/>
具体实现思路也很简单：
解决动态编译组件耗 Node.js 性能问题，可以在后台服务发布流程中，前置编译成 HTML 文件，发布到 CDN 或其他静态资源服务上，前台渲染直接使用这个已经编译好的 HTML。解决动态组装页面耗 Node.js 性能，也可以按照同样的物料组件的方式，前置编译 HTML 文件结果。
<br/>

> 此文章为 3 月 Day30 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
