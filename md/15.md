### 定制运营拖拽组件：如何实现运营搭建页面的拖拽功能？

#### 为什么需要拖拽布局组件？

搭建页面，原理就是通过配置数据，来驱动页面渲染对应内容，数据描述的是目标页面的布局情况，例如页面有多少个区块、每个区块里有多少个子区块，描述布局的数据也包含了每个区块里要渲染什么组件。
<br/>
这意味着，使用者只要能控制数据就行了， 就即使没有拖拽布局组建，也能够事件运营搭建页面的基本功能。<br/>
但是我们的运营搭建平台，目的就是要让非开发人员能低成本地搭建网页，不需要投入前端程序员的开发时间。
<br/>

#### 如何实现简单的拖拽布局功能？

对于拖拽布局功能，常见的功能要求是要在一个限定范围的“容器”内，让指定的“子模块”可以拖拽移动，在拖拽过程中还需要重新对模块进行排位。
具体实现可以分为 5 步：

1. 定义父容器和子模块；
2. 监听子模块的拖拽开始事件；
3. 监听拖拽过程经过父容器里哪些子模块；
4. 计算和重新渲染拖拽过程的临时布局；监听拖拽结束事件，更新最终模块布局。

<b>第一步定义父容器和子模块</b><br/>
这里“父容器”就是限定拖拽范围的 DOM，“子模块”就是在父容器 DOM 里的指定排序的 children  DOM，也就是子节点。在定义子模块的 DOM 时，我们还要加上 draggable 属性，让它能够实现鼠标拖拽的视觉效果。<br/>
这里要注意一点，这个 draggable 属性，仅仅是让 DOM 在鼠标拖拽时有视觉上的移动，当鼠标释放 DOM 时，DOM 会自动复原，不能直接实现拖拽功能。
<br/>
code...
效果图如下所示：
![](https://static001.geekbang.org/resource/image/c7/7d/c75565b32f488ff7782965d463dbfe7d.png?wh=1238x822)
<b>第二步监听子模块的拖拽开始事件</b><br/>

具体的监听方式，是以父容器的 DOM 作为事件代理来监听。这里，就要用到 DOM 的原生事件监听 API addEventListener，来监听 dragstart 事件。<br/>
拖拽子模块时，子模块的拖拽事件会通过“事件冒泡”的方式让父容器捕获，所以我们监听父容器，就能捕获到子模块的开始拖拽事件 dragstart，并且监听这个事件。<br/>
这个时候，我们需要定义一个变量，来标记当前拖拽中的子模块原始位置，给后续拖拽布局重新排序时候计算用。
<br/>
code...
<br/>
<b>第三步监听拖拽过程经过父容器里哪些子模块</b><br/>
这个需要监听父容器的 dragover 事件，基于拖拽事件，可以冒泡到父容器 DOM 来捕获，然后我们就可以通过 dragover 事件，来监听当前拖拽子组件的的鼠标位置，在哪个其它子模块的“上空”。<br/>

我们可以在事件里实时“捕获”鼠标拖拽到某个新位置下面的子模块 DOM，然后通过上一步实现的查找子模块位置的方法，计算出拖拽过程中的新位置序号，这个序号也就是当前“被拖拽的子模块”可能被“释放”的新位置。
<br/>
code...
<br/>
<b>第四步计算和重新渲染拖拽过程的临时布局</b><br/>
前面步骤中所有的子模块 DOM，是在父容器 DOM 里并排显示的。当“被拖拽的子模块”经过“某个其他子模块”上空时，就可以做个临时重新排序渲染，“被拖拽的子模块”从原来位置抽出来，整个子模块布局就按顺序补位，把“被拖拽的子模块”插入经过的“某个其他子模块”的位置，达到重新排序的操作。
<br/>
code...
<br/>

<b>第五步监听拖拽结束事件，更新最终模块布局</b><br/>
这里，我们监听父容器 DOM 的 dragend 事件，捕获最终位置，然后通过第四步的位置布局方法重新渲染子模块 DOM 的顺序。具体代码实现如下：
<br/>
code...
<br/>

最终效果如下：
![](https://static001.geekbang.org/resource/image/6a/a5/6a40d6b7c1b9c94652d0f21yy7ddafa5.gif?wh=600x385)

我们还可以改一下 HTML 代码里的 CSS 样式，让这个纵向的拖拽布局变成横向的拖拽布局功能：
<br/>

```
.drag-layout.horizontal {
  flex-direction: row;
  display: flex;
}
.drag-layout.horizontal .drag-item {
  width: 100px;
}
```

效果如下：
![](https://static001.geekbang.org/resource/image/66/62/661cfae39f146fcd24fec536fdcb3962.gif?wh=600x385)

#### 如何用 Vue3 封装拖拽布局的业务组件？

通过上面的简单实现过程，我们可以知道，拖拽布局操作核心就是在“父容器”里拖拽控制“子模块”，那么，在 Vue.js 中，我们就可以把“父容器”和“子模块”封装成两个独立的 Vue.js 组件来进行组合，实现拖拽功能。
<br/>

我们可以精简成三步来实现：

1. 第一步，封装父容器组件；
   这里主要的操作就是在父容器里直接监听 dragstart、dragover 和 dragend 事件。因为子容器会在父容器中使用，所以我们可以使用 Vue3 的 API provide/inject，来实现父子组件里的轻量级数据通信。
   <br/>
   provide/inject
2. 第二步，封装子容器组件；
   我们直接注册监听拖拽事件，同时，触发事件时来跟父容器进行数据通信。当子容器触发 dragstart 事件时，通过 inject 拿到共享的响应式数据，来传递拖拽选中的组件序号位置。
3. 第三步，组合父容器和子容器。
   这是最重要的，我们要将子容器和父容器组件进行组合，同时要处理子容器里可以用插槽来实现自定义拖拽的内容。所以，这里需要一个 Map，来注册有哪些自定义组件要进行拖拽，然后再加一个数组，来描述拖拽的初始位置。

<br/>

#### 如何优雅扩展拖拽布局组件的业务能力？

我们可以基于上述封装 Vue3 组件，对组件的 Props 进行调整和修改。
我们可以添加一个 horizontal 的 Prop，来控制整个拖拽功能的布局方向 CSS 样式，具体就是根据这个 horizontal 变量来判断是否要加上对应的 className。而且，还要改造一下父容器布局的 CSS 样式，也就是 drag-layout.vue 的代码。
修改如下：

```

<template>
  <div
    :class="{ [baseClassName]: true, ['is-horizontal']: props.horizontal }"
    @dragstart="onDragStart"
    @dragover="onDragOver"
    @dragend="onDragEnd"
  >
    <slot></slot>
  </div>
</template>

<script setup lang="ts">
// 省略原来其他代码 ...

// 修改代码
const props = defineProps<{ horizontal?: boolean }>();

// 省略原来其他代码 ...
</script>

```

布局样式：

```
.@{prefix-name}-drag-layout {
  // 省略原来其他代码 ...

  &.is-horizontal {
    flex-direction: row;
  }
}
```

效果如下：

![](https://static001.geekbang.org/resource/image/14/b1/145082b185944a770156f5aec66559b1.gif?wh=599x268)

[TODO 完整代码在这里...](../main/)
<br/>

> 此文章为 3 月 Day16 学习笔记，内容来源于极客时间《Vue 3 企业级项目实战课》，学习使我快乐，每天进步一点点 💪💪
